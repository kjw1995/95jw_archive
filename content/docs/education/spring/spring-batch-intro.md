---
title: Spring Batch - 배치와 스프링
weight: 10
---

## 배치 처리란?

```
┌─────────────────────────────────────────────────────────────┐
│                     배치 처리의 정의                          │
├─────────────────────────────────────────────────────────────┤
│  상호작용이나 중단 없이 유한한 양의 데이터를 처리하는 것         │
│  → 시작되면 아무런 개입 없이 완료까지 실행                     │
└─────────────────────────────────────────────────────────────┘
```

### 일반 애플리케이션 vs 배치 처리

| 구분 | 일반 애플리케이션 | 배치 처리 |
|------|------------------|----------|
| 사용자 상호작용 | 있음 (클릭, 입력) | 없음 |
| 실행 방식 | 이벤트 기반 | 스케줄 기반 |
| 데이터 양 | 소량 (건별 처리) | 대량 (일괄 처리) |
| 실행 시점 | 즉시 | 정해진 시간 |

---

## 배치 처리를 사용하는 이유

### 1. 정보 수집 및 준비

```
실시간 처리                    배치 처리
────────────                   ────────
요청 → 즉시 처리               요청 수집 → 일괄 처리
                               (필요한 정보를 미리 수집 가능)
```

### 2. 비즈니스 효율성

```
예시: 온라인 쇼핑몰 배송

[즉시 배송]
주문 → 바로 배송 준비 → 취소 시 비용 큼

[배치 배송]
주문 → 몇 시간 대기 → 취소 가능 기간 제공 → 일괄 배송
                     ↳ 취소 비용 절감
```

### 3. 자원 효율적 활용

```
데이터 과학 모델링 예시

┌─────────────────┐     ┌─────────────────┐
│  1단계: 모델 생성  │  →  │  2단계: 모델 사용  │
│   (시간 소요)      │     │    (빠른 처리)    │
│   배치 처리 적합   │     │   스트리밍 적합    │
└─────────────────┘     └─────────────────┘
```

---

## 배치 처리가 직면한 과제

### 4가지 핵심 과제

| 과제 | 설명 | 고려 사항 |
|------|------|----------|
| **사용성** | 코드 중심의 사용성 | 오류 처리, 디버깅 용이성, 단위 테스트 |
| **확장성** | 대용량 데이터 처리 | 병렬 처리, 분산 처리 |
| **가용성** | 서비스 지속성 | 장애 복구, 재시작 메커니즘 |
| **보안** | 데이터 보호 | 접근 제어, 암호화 |

### 사용성 관련 핵심 질문

```
✓ 공통 컴포넌트를 쉽게 확장할 수 있는가?
✓ 단위 테스트가 잘 구축되어 있는가?
✓ 실패 시 언제, 어디서, 왜 실패했는지 알 수 있는가?
```

---

## Java + Spring Batch를 선택하는 6가지 이유

| 이유 | 설명 |
|------|------|
| **유지보수성** | 배치 코드는 일반 앱보다 수명이 길어 중요 |
| **유연성** | WORA (Write Once Run Anywhere) |
| **확장성** | 다양한 확장 방안 제공 |
| **개발 리소스** | 풍부한 Java 개발자 풀 |
| **지원** | 커뮤니티 및 기업 지원 |
| **비용** | 오픈소스로 라이선스 비용 절감 |

### 배치 처리 확장 방안 비교

```
┌──────────────┬────────────────────────────┬──────────────────┐
│    방식      │          특징              │      제약        │
├──────────────┼────────────────────────────┼──────────────────┤
│ 메인프레임    │ 단일 하드웨어 내 병렬 처리  │ 용량 증설 제한    │
│ 커스텀 처리   │ 직접 구현                  │ 부하 분산 코딩 필요│
│ Spring Batch │ 프레임워크 지원            │ 상대적으로 적은 제약│
└──────────────┴────────────────────────────┴──────────────────┘
```

---

## Spring Batch 주요 사용 사례

### 1. ETL (Extract, Transform, Load)

```
┌─────────┐     ┌─────────┐     ┌─────────┐
│ Extract │  →  │Transform│  →  │  Load   │
│  (추출)  │     │  (변환)  │     │  (적재)  │
└─────────┘     └─────────┘     └─────────┘
     ↓               ↓               ↓
  DB에서 읽기    비즈니스 로직    다른 DB에 저장
```

### 2. 데이터 마이그레이션

```bash
# 시스템 간 데이터 이전
Legacy System  ──────────→  New System
              Spring Batch
```

### 3. 병렬 처리

- 멀티 코어 / 멀티 서버 분산 처리
- 웹 애플리케이션과 동일한 객체/데이터 소스 접근 가능

### 4. 워크로드 조정

- 시스템 부하 분산
- 피크 타임 외 시간에 처리

---

## Spring Batch 3-Layer 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                   Application Layer                         │
│        (사용자 코드, 비즈니스 로직, Job 구성)                  │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    Core Layer                           ││
│  │          (Job, Step, JobLauncher, JobParameters)        ││
│  │  ┌─────────────────────────────────────────────────────┐││
│  │  │              Infrastructure Layer                   │││
│  │  │    (ItemReader, ItemWriter, 재시작, 재시도 로직)      │││
│  │  └─────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

### 각 레이어 역할

| 레이어 | 역할 | 예시 |
|--------|------|------|
| **Application** | 사용자 코드, 비즈니스 로직 | Job 구성, 서비스 클래스 |
| **Core** | 배치 도메인 정의 | Job, Step, JobLauncher |
| **Infrastructure** | 공통 인프라 | ItemReader, ItemWriter, 재시도 |

---

## Spring Batch Job 기본 구조

### 개념적 구조

```
Job
 └── Step 1
 │    └── Tasklet or (ItemReader → ItemProcessor → ItemWriter)
 └── Step 2
 │    └── Tasklet or (ItemReader → ItemProcessor → ItemWriter)
 └── Step N
      └── ...
```

### 기본 Job 정의 예제

```java
@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public Tasklet accountTasklet() {
        return (contribution, chunkContext) -> {
            // 비즈니스 로직 수행
            System.out.println("계좌 처리 중...");
            return RepeatStatus.FINISHED;
        };
    }

    @Bean
    public Step accountStep() {
        return stepBuilderFactory.get("accountStep")
                .tasklet(accountTasklet())
                .build();
    }

    @Bean
    public Job accountJob() {
        return jobBuilderFactory.get("accountJob")
                .start(accountStep())
                .build();
    }
}
```

### 실행 흐름

```
Spring Boot 시작
      ↓
ApplicationContext 로드
      ↓
@EnableBatchProcessing으로 인프라 구성
      ↓
Job Bean 발견
      ↓
JobLauncher가 Job 자동 실행
```

---

## 관련 Spring Cloud 프로젝트

### Spring Cloud Task

```
┌─────────────────────────────────────────┐
│          Spring Cloud Task              │
├─────────────────────────────────────────┤
│ • 클라우드 환경의 유한한 태스크 실행      │
│ • Spring Batch와 통합                   │
│ • 동적 확장 기능                         │
│ • Job 시작/종료 이벤트 메시지 제공        │
└─────────────────────────────────────────┘
```

### Spring Cloud Data Flow

```
┌─────────────────────────────────────────┐
│       Spring Cloud Data Flow            │
├─────────────────────────────────────────┤
│ • 마이크로서비스 오케스트레이션           │
│ • 지원 플랫폼:                           │
│   - Cloud Foundry                       │
│   - Kubernetes                          │
│   - Local                               │
│ • 배치 앱의 동적 배포                    │
└─────────────────────────────────────────┘
```

---

## 흔한 오해 바로잡기

```
❌ 오해: Spring Batch는 스케줄러다

✅ 사실: Spring Batch는 스케줄러가 아님!
        프레임워크 내에 스케줄링 기능이 없음

┌─────────────────────────────────────────┐
│     Job 실행을 위한 별도 스케줄러 필요     │
├─────────────────────────────────────────┤
│ • Cron (리눅스 스케줄러)                 │
│ • Quartz (Java 스케줄러)                │
│ • Control-M (엔터프라이즈 스케줄러)       │
│ • Jenkins (CI/CD + 스케줄링)            │
│ • Kubernetes CronJob                    │
└─────────────────────────────────────────┘
```

---

## 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| **Job** | 하나 이상의 Step으로 구성된 배치 작업 단위 |
| **Step** | Job을 구성하는 독립적인 작업 단위 |
| **Tasklet** | 단순한 단일 태스크 실행 인터페이스 |
| **ETL** | Extract(추출), Transform(변환), Load(적재) |
| **Chunk** | 일정 개수의 아이템을 묶어 처리하는 단위 |
| **WORA** | Write Once Run Anywhere (Java 특성) |
