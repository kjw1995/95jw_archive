---
title: "동시성을 구현하는 재료"
weight: 3
---

운영체제는 실행(execution)을 실제 하드웨어에 배정하는 역할을 한다. 동시성 프로그래밍의 기본 재료는 **프로세스**와 **스레드**이다.

---

## 1. 프로세스 (Process)

프로세스는 컴퓨터에서 **실행 중인 프로그램의 인스턴스**를 가리킨다. 각 프로세스는 운영체제로부터 독립된 자원을 할당받는다.

### 프로세스의 메모리 구조

```
┌────────────────┐
│   프로세스 A    │
├────────────────┤
│  Code (텍스트)  │ 실행할 명령어
├────────────────┤
│  Data (데이터)  │ 전역/정적 변수
├────────────────┤
│  Heap (힙)     │ 동적 할당 영역
├────────────────┤
│  Stack (스택)   │ 지역 변수, 호출 정보
└────────────────┘
```

### 프로세스의 특징

| 항목 | 설명 |
|:-----|:-----|
| 독립성 | 각 프로세스는 별도의 주소 공간을 가짐 |
| 격리성 | 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않음 |
| 자원 소유 | 메모리, 파일 핸들, 소켓 등 독립 자원 보유 |
| 통신 비용 | 프로세스 간 통신(IPC)은 비용이 큼 |

### 프로세스 간 통신 (IPC)

프로세스끼리는 주소 공간이 분리되어 있어 데이터를 직접 공유할 수 없다. 운영체제가 제공하는 **IPC 메커니즘**을 사용해야 한다.

| 방식 | 설명 |
|:-----|:-----|
| 파이프 (Pipe) | 단방향 데이터 스트림 |
| 소켓 (Socket) | 네트워크를 통한 양방향 통신 |
| 공유 메모리 | 같은 메모리 영역을 매핑하여 공유 |
| 메시지 큐 | 메시지를 큐에 넣고 꺼내는 방식 |

---

## 2. 스레드 (Thread)

스레드는 어떤 특정한 결과를 내기 위해 만들어진 **독립적인 인스트럭션의 집합**이며, **실행의 단위**다. 운영체제가 독립적으로 실행하고 관리한다.

### 프로세스와 스레드의 관계

```
┌──────────────────────┐
│     프로세스           │
│  ┌────┐┌────┐┌────┐  │
│  │ T1 ││ T2 ││ T3 │  │
│  └────┘└────┘└────┘  │
│                      │
│  Code  Data  Heap    │ ← 공유
│                      │
│  Stack Stack Stack   │ ← 각자
│  (T1)  (T2)  (T3)   │
└──────────────────────┘
```

- 각 프로세스는 **하나 이상의 스레드**를 가진다
- 프로세스에 포함되지 않은 스레드는 존재할 수 없다
- 같은 프로세스의 스레드끼리 **Code, Data, Heap을 공유**한다
- 각 스레드는 **독립적인 Stack과 PC(Program Counter)**를 가진다

### 스레드의 공유/비공유 영역

| 구분 | 공유 (프로세스 전체) | 비공유 (스레드별) |
|:-----|:---------------------|:------------------|
| 메모리 | 코드, 데이터, 힙 | 스택 |
| 레지스터 | - | PC, SP 등 |
| 기타 | 파일 핸들, 소켓 | 스레드 ID, 우선순위 |

---

## 3. 프로세스 vs 스레드

| 구분 | 프로세스 | 스레드 |
|:-----|:---------|:-------|
| 정의 | 실행 중인 프로그램 | 프로세스 내 실행 단위 |
| 주소 공간 | 독립 | 프로세스 내 공유 |
| 생성 비용 | 높음 | 낮음 |
| 전환 비용 | 높음 (컨텍스트 스위칭) | 낮음 |
| 데이터 공유 | IPC 필요 (느림) | 직접 공유 (빠름) |
| 안정성 | 높음 (격리) | 낮음 (하나 죽으면 전체 영향) |
| 동기화 | 불필요 (독립) | 필요 (공유 자원 보호) |

### 왜 스레드를 쓰는가?

동시적 애플리케이션을 작성하는 데는 스레드를 사용하는 것이 간편하다.

1. **전환이 쉽다** - 같은 주소 공간이므로 컨텍스트 스위칭 비용이 적다
2. **데이터 공유가 빠르다** - 주소 공간을 공유하므로 IPC 없이 직접 접근 가능
3. **생성 비용이 적다** - 새 주소 공간을 할당할 필요가 없다

> 그러나 그만큼 접근 제어나 동기화에 주의하지 않으면 **데이터 오염**을 일으키기도 쉽다.

---

## 4. 컨텍스트 스위칭 (Context Switching)

CPU가 한 실행 단위에서 다른 실행 단위로 전환할 때, 현재 상태를 저장하고 다음 상태를 복원하는 과정이다.

### 동작 과정

```
  스레드 A 실행 중
        │
        ▼
┌────────────────┐
│ ① A 상태 저장   │
│   (PC, 레지스터) │
└───────┬────────┘
        │
        ▼
┌────────────────┐
│ ② B 상태 복원   │
│   (PC, 레지스터) │
└───────┬────────┘
        │
        ▼
  스레드 B 실행 시작
```

### 프로세스 vs 스레드 컨텍스트 스위칭

| 구분 | 프로세스 전환 | 스레드 전환 |
|:-----|:-------------|:-----------|
| 메모리 매핑 | 교체 필요 | 불필요 (같은 주소 공간) |
| 캐시 | 무효화 (TLB 플러시) | 유지 가능 |
| 저장/복원 | 레지스터 + 메모리 정보 | 레지스터만 |
| 비용 | 높음 | 낮음 |

스레드 전환이 프로세스 전환보다 가벼운 이유는 **같은 주소 공간을 공유**하기 때문에 메모리 관련 정보를 바꿀 필요가 없기 때문이다.

---

## 5. Java에서의 스레드

### 스레드 생성 방법

#### 방법 1: Thread 상속

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(
            Thread.currentThread().getName()
            + " 실행");
    }

    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // run()이 아닌 start() 호출
    }
}
```

#### 방법 2: Runnable 구현

```java
public class MyRunnable implements Runnable {

    @Override
    public void run() {
        System.out.println(
            Thread.currentThread().getName()
            + " 실행");
    }

    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
```

#### 방법 3: 람다식 (Java 8+)

```java
public class LambdaThread {

    public static void main(String[] args) {
        Thread t = new Thread(() ->
            System.out.println(
                Thread.currentThread().getName()
                + " 실행")
        );
        t.start();
    }
}
```

### start() vs run()

| 메서드 | 동작 |
|:-------|:-----|
| `start()` | 새 스레드를 생성하고 그 스레드에서 `run()` 실행 |
| `run()` | 현재 스레드에서 직접 실행 (새 스레드 생성 안 됨) |

```java
Thread t = new Thread(() ->
    System.out.println(
        Thread.currentThread().getName()));

t.run();    // "main" 출력 (새 스레드 X)
t.start();  // "Thread-0" 출력 (새 스레드 O)
```

### 스레드 생명주기

```
   NEW (생성)
     │
     │ start()
     ▼
   RUNNABLE (실행 가능)
     │
     ├── CPU 할당 ──→ 실행 중
     │                  │
     │   ┌──────────────┤
     │   │              │
     │   ▼              │
     │ BLOCKED          │
     │ WAITING          │
     │ TIMED_WAITING    │
     │   │              │
     │   └──→ 복귀 ────┘
     │
     ▼
   TERMINATED (종료)
```

| 상태 | 설명 |
|:-----|:-----|
| `NEW` | 생성됨, 아직 `start()` 호출 전 |
| `RUNNABLE` | 실행 가능 (CPU 대기 또는 실행 중) |
| `BLOCKED` | 락 획득 대기 중 |
| `WAITING` | 다른 스레드의 알림 대기 중 |
| `TIMED_WAITING` | 지정 시간만큼 대기 중 |
| `TERMINATED` | 실행 완료 |

---

## 6. 스레드의 위험성

스레드는 메모리를 공유하므로 동기화 없이 접근하면 문제가 발생한다.

### 경쟁 조건 (Race Condition)

```java
public class Counter {
    private int count = 0;

    // 동기화 없이 공유 변수 접근
    public void increment() {
        count++;  // read-modify-write
    }
}
```

```
  Thread A         Thread B
  ────────         ────────
  read count (0)
                   read count (0)
  count + 1 = 1
                   count + 1 = 1
  write count (1)
                   write count (1)

  기대값: 2 → 실제값: 1
```

### 가시성 문제 (Visibility)

```java
public class StopThread {
    private boolean stopped = false;

    public void run() {
        // stopped 변경을 영원히
        // 보지 못할 수 있음
        while (!stopped) {
            doWork();
        }
    }

    public void stop() {
        stopped = true;
    }
}
```

CPU 캐시에 의해 한 스레드의 변경이 다른 스레드에 보이지 않을 수 있다.

### 해결 방향

| 문제 | 해결 |
|:-----|:-----|
| 경쟁 조건 | `synchronized`, `Lock`, `Atomic` |
| 가시성 | `volatile`, `synchronized` |
| 데이터 오염 | 불변 객체, 스레드 한정 |

---

## 요약

### 프로세스와 스레드 핵심

| 항목 | 내용 |
|:-----|:-----|
| 프로세스 | 실행 중인 프로그램 인스턴스, 독립된 주소 공간 |
| 스레드 | 프로세스 내 실행 단위, 주소 공간 공유 |
| 관계 | 프로세스 ⊃ 스레드 (1:N) |
| 공유 자원 | Code, Data, Heap (스레드 간 공유) |
| 비공유 자원 | Stack, PC (스레드별 독립) |

### 스레드의 장점과 대가

```
장점                   대가
──────                ──────
전환 비용 낮음          동기화 필요
데이터 공유 빠름        경쟁 조건 위험
생성 비용 적음          가시성 문제
응답성 향상            디버깅 어려움
```

> 스레드의 편리함을 얻으려면, **동기화라는 대가**를 반드시 치러야 한다.
