# 메서드 참조 (Method Reference)

## 개념 정의

**메서드 참조**는 기존의 메서드 정의를 재활용해서 람다처럼 전달하는 방식이다. 특정 메서드만을 호출하는 람다의 **축약형**으로, 메서드명을 직접 참조하여 **가독성을 높인다**.

```java
// 람다 표현식
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

// 메서드 참조 활용
inventory.sort(comparing(Apple::getWeight));
```

## 메서드 참조 문법

메서드명 앞에 **구분자(::)**를 붙여서 사용한다.

```
클래스명::메서드명
객체참조::메서드명
```

---

## 메서드 참조의 3가지 유형

### 1. 정적 메서드 참조 (Static Method Reference)

```java
// 람다
(args) -> ClassName.staticMethod(args)

// 메서드 참조
ClassName::staticMethod
```

**예제**
```java
// Integer.parseInt
Function<String, Integer> toInt1 = s -> Integer.parseInt(s);
Function<String, Integer> toInt2 = Integer::parseInt;

toInt2.apply("123");  // 123

// Math.max
BinaryOperator<Integer> max1 = (a, b) -> Math.max(a, b);
BinaryOperator<Integer> max2 = Math::max;

max2.apply(5, 3);  // 5

// System.currentTimeMillis
Supplier<Long> time1 = () -> System.currentTimeMillis();
Supplier<Long> time2 = System::currentTimeMillis;
```

### 2. 인스턴스 메서드 참조 (임의 객체)

**첫 번째 인수**가 메서드의 수신자(receiver)가 되는 경우

```java
// 람다
(arg0, rest) -> arg0.instanceMethod(rest)

// 메서드 참조
ClassName::instanceMethod
```

**예제**
```java
// String.length
Function<String, Integer> len1 = s -> s.length();
Function<String, Integer> len2 = String::length;

len2.apply("hello");  // 5

// String.compareTo
Comparator<String> comp1 = (s1, s2) -> s1.compareTo(s2);
Comparator<String> comp2 = String::compareTo;

// String.toUpperCase
Function<String, String> upper1 = s -> s.toUpperCase();
Function<String, String> upper2 = String::toUpperCase;

upper2.apply("hello");  // "HELLO"

// String.startsWith
BiPredicate<String, String> startsWith1 = (s, prefix) -> s.startsWith(prefix);
BiPredicate<String, String> startsWith2 = String::startsWith;

startsWith2.test("hello", "he");  // true
```

### 3. 기존 객체의 인스턴스 메서드 참조

특정 **객체**의 인스턴스 메서드를 참조

```java
// 람다
(args) -> expr.instanceMethod(args)

// 메서드 참조
expr::instanceMethod
```

**예제**
```java
// 특정 객체의 메서드 참조
String prefix = "Hello, ";
Function<String, String> greet1 = s -> prefix.concat(s);
Function<String, String> greet2 = prefix::concat;

greet2.apply("World");  // "Hello, World"

// System.out::println
Consumer<String> print1 = s -> System.out.println(s);
Consumer<String> print2 = System.out::println;

print2.accept("Hello");  // "Hello" 출력

// List의 메서드 참조
List<String> list = new ArrayList<>();
Consumer<String> add1 = s -> list.add(s);
Consumer<String> add2 = list::add;

add2.accept("item");  // list에 "item" 추가
```

---

## 메서드 참조 유형 비교표

| 유형 | 람다 | 메서드 참조 | 예시 |
|------|------|------------|------|
| 정적 메서드 | `args -> Class.method(args)` | `Class::method` | `Integer::parseInt` |
| 임의 객체의 인스턴스 메서드 | `(a, b) -> a.method(b)` | `Class::method` | `String::compareTo` |
| 특정 객체의 인스턴스 메서드 | `args -> obj.method(args)` | `obj::method` | `System.out::println` |

---

## 생성자 참조 (Constructor Reference)

`ClassName::new` 형식으로 생성자를 참조할 수 있다.

### 기본 생성자 (인수 없음)
```java
// Supplier: () -> T
Supplier<Apple> supplier1 = () -> new Apple();
Supplier<Apple> supplier2 = Apple::new;

Apple apple = supplier2.get();

// ArrayList 생성
Supplier<List<String>> listFactory = ArrayList::new;
List<String> list = listFactory.get();
```

### 단일 인수 생성자
```java
// Function: T -> R
// Apple(Integer weight) 생성자
Function<Integer, Apple> factory1 = weight -> new Apple(weight);
Function<Integer, Apple> factory2 = Apple::new;

Apple apple = factory2.apply(150);

// 무게 리스트를 사과 리스트로 변환
List<Integer> weights = Arrays.asList(7, 3, 4, 10);
List<Apple> apples = map(weights, Apple::new);

public List<Apple> map(List<Integer> list, Function<Integer, Apple> f) {
    List<Apple> result = new ArrayList<>();
    for (Integer i : list) {
        result.add(f.apply(i));
    }
    return result;
}
```

### 두 개 인수 생성자
```java
// BiFunction: (T, U) -> R
// Apple(String color, Integer weight) 생성자
BiFunction<String, Integer, Apple> factory1 = (color, weight) -> new Apple(color, weight);
BiFunction<String, Integer, Apple> factory2 = Apple::new;

Apple apple = factory2.apply("GREEN", 150);
```

### 세 개 이상 인수 생성자
기본 제공되는 함수형 인터페이스가 없으므로 직접 정의해야 한다.

```java
// 세 개 인수용 함수형 인터페이스 정의
@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}

// Apple(String color, Integer weight, String origin) 생성자
TriFunction<String, Integer, String, Apple> factory = Apple::new;
Apple apple = factory.apply("RED", 200, "Korea");
```

---

## 실전 활용 예제

### 1. 컬렉션 정렬
```java
List<String> names = Arrays.asList("Charlie", "Alice", "Bob");

// 람다
names.sort((s1, s2) -> s1.compareTo(s2));

// 메서드 참조
names.sort(String::compareTo);

// Comparator 활용
names.sort(Comparator.comparing(String::length));  // 길이순
names.sort(Comparator.comparing(String::toLowerCase));  // 대소문자 무시
```

### 2. 스트림 연산
```java
List<String> words = Arrays.asList("hello", "world", "java");

// map + 메서드 참조
List<Integer> lengths = words.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 5, 4]

// filter + 메서드 참조
List<String> nonEmpty = words.stream()
    .filter(s -> !s.isEmpty())  // 또는 Predicate.not(String::isEmpty) (Java 11+)
    .collect(Collectors.toList());

// forEach + 메서드 참조
words.forEach(System.out::println);

// reduce + 메서드 참조
Optional<String> concat = words.stream()
    .reduce(String::concat);
// "helloworldjava"
```

### 3. 객체 생성 팩토리
```java
Map<String, Supplier<Fruit>> fruitFactory = new HashMap<>();
fruitFactory.put("apple", Apple::new);
fruitFactory.put("orange", Orange::new);
fruitFactory.put("banana", Banana::new);

public Fruit createFruit(String type) {
    Supplier<Fruit> supplier = fruitFactory.get(type.toLowerCase());
    if (supplier != null) {
        return supplier.get();
    }
    throw new IllegalArgumentException("Unknown fruit: " + type);
}
```

### 4. Optional과 함께 사용
```java
Optional<String> optional = Optional.of("hello");

// map + 메서드 참조
Optional<Integer> length = optional.map(String::length);

// orElseGet + 생성자 참조
String result = optional.orElseGet(String::new);

// ifPresent + 메서드 참조
optional.ifPresent(System.out::println);
```

### 5. 배열 생성자 참조
```java
// 배열 생성자 참조
IntFunction<int[]> arrayFactory = int[]::new;
int[] array = arrayFactory.apply(5);  // new int[5]

// 스트림에서 배열로 변환
String[] names = stream.toArray(String[]::new);

// Function으로도 가능
Function<Integer, String[]> stringArrayFactory = String[]::new;
String[] arr = stringArrayFactory.apply(10);  // new String[10]
```

---

## 메서드 참조 vs 람다 선택 가이드

| 상황 | 권장 |
|------|------|
| 단순 메서드 호출 | 메서드 참조 |
| 추가 로직 필요 | 람다 |
| 여러 인수 조합 필요 | 람다 |
| 가독성이 떨어지는 메서드 참조 | 람다 |

```java
// 메서드 참조 권장
list.forEach(System.out::println);
list.sort(String::compareTo);
stream.map(String::toUpperCase);

// 람다 권장 (추가 로직)
list.forEach(item -> {
    validate(item);
    System.out.println(item);
});

// 람다 권장 (인수 변환)
list.sort((s1, s2) -> s1.toLowerCase().compareTo(s2.toLowerCase()));
```

---

## 형식 검사와 메서드 참조

컴파일러는 람다 표현식과 마찬가지로 메서드 참조가 주어진 함수형 인터페이스와 **호환되는지** 확인한다.

```java
// 호환성 검사 과정
BiPredicate<List<String>, String> contains = List::contains;

// 1. BiPredicate<List<String>, String> 확인
// 2. test 메서드 시그니처: (List<String>, String) -> boolean
// 3. List::contains는 (List가 첫 번째 인수, String이 contains의 인수)
// 4. List.contains(String)은 boolean 반환
// 5. 호환됨!
```

---

## 핵심 정리

1. **메서드 참조**는 람다의 축약형으로 `클래스명::메서드명` 형식 사용
2. **3가지 유형**: 정적 메서드, 임의 객체의 인스턴스 메서드, 특정 객체의 인스턴스 메서드
3. **생성자 참조**: `ClassName::new`로 객체 생성 로직 전달
4. **배열 생성자 참조**: `Type[]::new`로 배열 생성
5. 컴파일러가 대상 형식과의 **호환성**을 검사
6. 단순 메서드 호출에는 **메서드 참조**, 추가 로직 필요 시 **람다** 사용
7. 가독성과 간결성 향상에 크게 기여
