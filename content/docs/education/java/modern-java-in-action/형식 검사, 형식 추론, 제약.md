# 형식 검사, 형식 추론, 제약

## 1. 형식 검사 (Type Checking)

### 대상 형식 (Target Type)
람다가 사용되는 **컨텍스트**에서 기대되는 람다 표현식의 형식을 **대상 형식(target type)**이라고 한다.

```java
List<Apple> heavierThan150g = filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```

### 형식 확인 과정

```
filter(inventory, (Apple apple) -> apple.getWeight() > 150)
        ↓
1. filter 메서드 선언 확인
        ↓
2. 두 번째 파라미터로 Predicate<Apple> 형식(대상 형식) 기대
        ↓
3. Predicate<Apple>은 test 메서드를 정의하는 함수형 인터페이스
        ↓
4. test 메서드는 Apple → boolean 함수 디스크립터 가짐
        ↓
5. 전달된 람다가 이 요구사항과 일치하는지 확인
        ↓
6. 형식 검사 완료!
```

### 예외 호환성
람다 표현식이 예외를 던질 수 있다면, 추상 메서드도 같은 예외를 `throws`로 선언해야 한다.

```java
// 함수형 인터페이스
@FunctionalInterface
interface FileProcessor {
    String process(String path) throws IOException;  // 예외 선언 필요
}

// 람다 사용
FileProcessor processor = path -> {
    return new String(Files.readAllBytes(Paths.get(path)));  // IOException 발생 가능
};
```

---

## 2. 같은 람다, 다른 함수형 인터페이스

**대상 형식(target typing)** 덕분에 같은 람다 표현식이 호환되는 추상 메서드를 가진 **다른 함수형 인터페이스**로 사용될 수 있다.

```java
// 같은 람다, 다른 대상 형식
Callable<Integer> c = () -> 42;
PrivilegedAction<Integer> p = () -> 42;

// 두 인터페이스 모두 () -> Integer 시그니처를 가짐
```

### 다이아몬드 연산자와의 유사성
```java
// 제네릭에서 대상 형식 추론
List<String> list = new ArrayList<>();  // 대상 형식으로 String 추론

// 람다에서 대상 형식 추론
Comparator<String> comp = (s1, s2) -> s1.compareTo(s2);  // String 추론
```

### 특별한 void 호환 규칙
람다의 바디에 **일반 표현식**이 있으면 `void`를 반환하는 함수 디스크립터와도 호환된다.

```java
// List.add는 boolean을 반환하지만...
Predicate<String> p = s -> list.add(s);  // boolean 반환 - OK

// Consumer는 void를 기대하지만...
Consumer<String> c = s -> list.add(s);   // void 호환 - OK!
```

> `list.add(s)`는 `boolean`을 반환하지만, 표현식이므로 `void` 컨텍스트에서도 유효하다.

---

## 3. 형식 추론 (Type Inference)

자바 컴파일러는 **대상 형식**을 이용해 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 이를 통해 **파라미터 타입을 생략**할 수 있다.

### 형식 추론 적용
```java
// 형식을 명시적으로 지정
Comparator<Apple> c1 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 형식 추론 적용
Comparator<Apple> c2 = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());

// 더 간결하게
List<Apple> greenApples = filter(inventory, apple -> GREEN.equals(apple.getColor()));
```

### 형식 추론 동작 원리
```java
// 컴파일러가 대상 형식 확인
filter(inventory, apple -> GREEN.equals(apple.getColor()))
                    ↓
// Predicate<Apple>의 test 메서드 시그니처: Apple -> boolean
                    ↓
// apple은 Apple 타입임을 추론
```

### 형식 추론 적용 가이드

| 상황 | 권장 |
|------|------|
| 단일 파라미터 | 형식 생략 |
| 다중 파라미터 (복잡한 로직) | 형식 명시 (가독성) |
| 컨텍스트가 명확할 때 | 형식 생략 |
| 오버로드된 메서드 | 형식 명시 (모호성 해소) |

```java
// 단일 파라미터 - 형식 생략 권장
list.forEach(item -> System.out.println(item));

// 복잡한 로직 - 형식 명시 고려
BiFunction<String, Integer, User> factory = (String name, Integer age) -> {
    validateName(name);
    validateAge(age);
    return new User(name, age);
};

// 오버로드 메서드에서 모호성 해소
process((String s) -> s.length());  // String 버전 선택
```

---

## 4. 지역 변수 사용과 제약

### 람다 캡처링 (Lambda Capturing)
람다 표현식에서 **자유 변수(free variable)**를 활용하는 것을 **람다 캡처링**이라고 한다.

> **자유 변수**: 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);  // portNumber 캡처
```

### 지역 변수 제약

람다에서 **지역 변수**를 참조하려면:
1. 명시적으로 `final`로 선언되어야 하거나
2. 실질적으로 `final`처럼 사용되어야 한다 (effectively final)

```java
// 정상 - final 선언
final int port = 1337;
Runnable r1 = () -> System.out.println(port);

// 정상 - effectively final (재할당 없음)
int port2 = 1337;
Runnable r2 = () -> System.out.println(port2);

// 컴파일 에러! - 재할당 발생
int port3 = 1337;
Runnable r3 = () -> System.out.println(port3);  // 에러!
port3 = 31337;  // 재할당
```

### 인스턴스 변수 vs 지역 변수

| 구분 | 인스턴스 변수 | 지역 변수 |
|------|--------------|----------|
| 저장 위치 | 힙(Heap) | 스택(Stack) |
| 공유 | 스레드 간 공유 | 스레드별 독립 |
| 캡처 제약 | 없음 | final 또는 effectively final |
| 변경 가능 | 가능 | 불가능 (캡처 후) |

```java
public class Example {
    private int instanceVar = 10;  // 힙에 저장

    public Runnable createRunnable() {
        int localVar = 20;  // 스택에 저장

        return () -> {
            instanceVar = 100;  // OK - 인스턴스 변수 변경 가능
            // localVar = 200;  // 컴파일 에러! - 지역 변수 변경 불가
            System.out.println(instanceVar + localVar);
        };
    }
}
```

### 지역 변수 제약의 이유

```
스레드 A                           스레드 B
─────────                         ─────────
int localVar = 1337;
                                  람다 실행 시작
람다 생성 (localVar 캡처)
                                  localVar 사용 (복사본)
스레드 종료
(localVar 메모리 해제)              여전히 실행 중...
```

1. **스레드 안전성**: 지역 변수는 스택에 저장되어 스레드 종료 시 사라짐
2. **복사본 사용**: 람다는 지역 변수의 **복사본**을 사용
3. **일관성 보장**: 복사본이 변경되면 원본과 불일치 발생
4. **final 제약**: 복사본과 원본의 일관성을 보장하기 위함

### 제약 우회 방법

지역 변수를 변경해야 할 때의 대안:

```java
// 방법 1: 배열 사용
int[] counter = {0};
Runnable r = () -> counter[0]++;  // OK - 배열 참조는 final, 내용은 변경 가능

// 방법 2: AtomicInteger 사용 (스레드 안전)
AtomicInteger atomicCounter = new AtomicInteger(0);
Runnable r2 = () -> atomicCounter.incrementAndGet();

// 방법 3: 래퍼 클래스 사용
class Counter { int value = 0; }
Counter c = new Counter();
Runnable r3 = () -> c.value++;
```

---

## 5. 클로저 (Closure)

### 클로저란?
함수의 **비지역 변수를 자유롭게 참조**할 수 있는 함수의 인스턴스이다. 클로저는 외부에 정의된 변수의 값에 접근하고, 값을 바꿀 수 있다.

### 람다와 클로저의 관계

```java
// 일반적인 클로저 (다른 언어)
function createCounter() {
    let count = 0;
    return function() {
        return ++count;  // count 변경 가능
    };
}

// 자바 람다 - 제한된 클로저
int count = 0;
Supplier<Integer> counter = () -> count;  // count 읽기만 가능
// count++;  // 변경하면 컴파일 에러
```

### 자바 람다의 클로저 특성

| 특성 | 완전한 클로저 | 자바 람다 |
|------|-------------|----------|
| 외부 변수 참조 | O | O |
| 외부 변수 변경 | O | X (지역 변수) |
| 인수로 전달 | O | O |

> 자바 람다는 **지역 변수의 값을 변경할 수 없다**는 점에서 완전한 클로저가 아니다.

### 클로저 동작 예시

```java
public class ClosureExample {
    private int instanceCounter = 0;

    public Supplier<Integer> createCounter() {
        // 인스턴스 변수는 변경 가능 - 클로저처럼 동작
        return () -> ++instanceCounter;
    }

    public static void main(String[] args) {
        ClosureExample example = new ClosureExample();
        Supplier<Integer> counter = example.createCounter();

        System.out.println(counter.get());  // 1
        System.out.println(counter.get());  // 2
        System.out.println(counter.get());  // 3
    }
}
```

---

## 핵심 정리

1. **대상 형식(Target Type)**: 람다가 사용되는 컨텍스트에서 기대되는 형식
2. **같은 람다, 다른 인터페이스**: 대상 형식에 따라 같은 람다가 다른 함수형 인터페이스로 사용 가능
3. **void 호환 규칙**: 표현식 반환값이 있어도 void 컨텍스트와 호환
4. **형식 추론**: 컴파일러가 대상 형식으로 파라미터 타입 추론
5. **람다 캡처링**: 외부 변수를 람다 내부에서 사용
6. **지역 변수 제약**: final 또는 effectively final만 캡처 가능
7. **이유**: 람다는 지역 변수의 복사본을 사용하므로 일관성 유지 필요
8. **클로저**: 자바 람다는 제한된 형태의 클로저 (지역 변수 변경 불가)
