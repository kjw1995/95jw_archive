# 실행 어라운드 패턴 (Execute Around Pattern)

## 개념 정의

**실행 어라운드 패턴**은 자원 처리(데이터베이스, 파일 등)에서 자주 사용되는 패턴이다. 자원을 **열고**, **처리**한 다음, **닫는** 순서로 이루어지며, 설정(setup)과 정리(cleanup) 과정이 실제 작업을 **둘러싸는(around)** 형태이다.

```
┌─────────────────────────────────────┐
│          Setup (설정)               │
│   - 자원 열기                        │
│   - 연결 설정                        │
├─────────────────────────────────────┤
│       실제 작업 (가변적)             │  ← 람다로 전달
│   - 데이터 읽기/쓰기                 │
│   - 쿼리 실행                        │
├─────────────────────────────────────┤
│         Cleanup (정리)              │
│   - 자원 닫기                        │
│   - 연결 해제                        │
└─────────────────────────────────────┘
```

## 문제 상황

### 기존 코드의 한계
```java
public String processFile() throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return br.readLine();  // 실제 필요한 작업 - 한 줄만 읽음
    }
}
```

**문제점**: 두 줄을 읽거나, 특정 단어를 찾는 등 다른 동작이 필요하면 메서드를 새로 만들어야 한다.

## 람다를 활용한 실행 어라운드 패턴 구현

### 1단계: 동작 파라미터화
어떤 동작을 수행할지 람다로 전달받는다.

```java
// 원하는 동작을 람다로 표현
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

### 2단계: 함수형 인터페이스 정의
```java
@FunctionalInterface
public interface BufferedReaderProcessor {
    String process(BufferedReader br) throws IOException;
}
```

### 3단계: 동작 실행
```java
public String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return p.process(br);  // 전달받은 동작 실행
    }
}
```

### 4단계: 람다 전달
```java
// 한 줄 읽기
String oneLine = processFile((BufferedReader br) -> br.readLine());

// 두 줄 읽기
String twoLines = processFile((BufferedReader br) -> br.readLine() + br.readLine());

// 모든 줄 읽기
String allLines = processFile(br -> {
    StringBuilder sb = new StringBuilder();
    String line;
    while ((line = br.readLine()) != null) {
        sb.append(line).append("\n");
    }
    return sb.toString();
});

// 특정 단어 포함 줄만 읽기
String filteredLines = processFile(br -> {
    return br.lines()
             .filter(line -> line.contains("Java"))
             .collect(Collectors.joining("\n"));
});
```

## 제네릭을 활용한 범용 버전

### 범용 함수형 인터페이스
```java
@FunctionalInterface
public interface ResourceProcessor<T, R> {
    R process(T resource) throws Exception;
}
```

### 범용 실행 어라운드 메서드
```java
public <R> R processFile(String path, ResourceProcessor<BufferedReader, R> processor)
        throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return processor.process(br);
    }
}

// 사용 예시
int lineCount = processFile("data.txt", br -> (int) br.lines().count());
List<String> lines = processFile("data.txt", br -> br.lines().collect(Collectors.toList()));
boolean hasData = processFile("data.txt", br -> br.readLine() != null);
```

## 실전 활용 예제

### 1. 데이터베이스 연결 관리
```java
@FunctionalInterface
public interface ConnectionProcessor<R> {
    R process(Connection conn) throws SQLException;
}

public class DatabaseUtil {
    public static <R> R withConnection(ConnectionProcessor<R> processor)
            throws SQLException {
        Connection conn = null;
        try {
            conn = DriverManager.getConnection(DB_URL, USER, PASS);
            return processor.process(conn);
        } finally {
            if (conn != null) conn.close();
        }
    }
}

// 사용
List<User> users = DatabaseUtil.withConnection(conn -> {
    PreparedStatement ps = conn.prepareStatement("SELECT * FROM users");
    ResultSet rs = ps.executeQuery();
    List<User> result = new ArrayList<>();
    while (rs.next()) {
        result.add(new User(rs.getString("name"), rs.getInt("age")));
    }
    return result;
});
```

### 2. 트랜잭션 관리
```java
@FunctionalInterface
public interface TransactionAction<R> {
    R execute(Connection conn) throws Exception;
}

public <R> R executeInTransaction(TransactionAction<R> action) throws Exception {
    Connection conn = dataSource.getConnection();
    try {
        conn.setAutoCommit(false);
        R result = action.execute(conn);
        conn.commit();
        return result;
    } catch (Exception e) {
        conn.rollback();
        throw e;
    } finally {
        conn.close();
    }
}

// 사용
Integer newUserId = executeInTransaction(conn -> {
    // 여러 쿼리를 하나의 트랜잭션으로
    insertUser(conn, user);
    insertUserProfile(conn, profile);
    return getUserId(conn, user.getEmail());
});
```

### 3. 락(Lock) 관리
```java
@FunctionalInterface
public interface LockAction<R> {
    R execute() throws Exception;
}

public class LockUtil {
    private static final ReentrantLock lock = new ReentrantLock();

    public static <R> R withLock(LockAction<R> action) throws Exception {
        lock.lock();
        try {
            return action.execute();
        } finally {
            lock.unlock();
        }
    }
}

// 사용
int result = LockUtil.withLock(() -> {
    // 동기화가 필요한 작업
    sharedCounter++;
    return sharedCounter;
});
```

### 4. 타이머/성능 측정
```java
@FunctionalInterface
public interface TimedAction<R> {
    R execute() throws Exception;
}

public static <R> R measureTime(String taskName, TimedAction<R> action) throws Exception {
    long start = System.currentTimeMillis();
    try {
        return action.execute();
    } finally {
        long elapsed = System.currentTimeMillis() - start;
        System.out.println(taskName + " took " + elapsed + "ms");
    }
}

// 사용
List<String> data = measureTime("데이터 로딩", () -> {
    return loadDataFromDatabase();
});
```

### 5. 리소스 풀 관리
```java
public class ResourcePool<T> {
    private final Queue<T> pool;
    private final Supplier<T> factory;

    public <R> R withResource(Function<T, R> action) {
        T resource = pool.poll();
        if (resource == null) {
            resource = factory.get();
        }
        try {
            return action.apply(resource);
        } finally {
            pool.offer(resource);  // 풀에 반환
        }
    }
}

// 사용
ResourcePool<StringBuilder> sbPool = new ResourcePool<>(StringBuilder::new);
String result = sbPool.withResource(sb -> {
    sb.setLength(0);  // 재사용을 위해 초기화
    sb.append("Hello").append(" ").append("World");
    return sb.toString();
});
```

## 패턴의 장점

| 장점 | 설명 |
|------|------|
| **재사용성** | 설정/정리 코드를 한 번만 작성 |
| **안전성** | 자원 정리가 항상 실행됨 |
| **유연성** | 다양한 동작을 람다로 전달 가능 |
| **관심사 분리** | 자원 관리와 비즈니스 로직 분리 |
| **코드 중복 제거** | try-finally 패턴의 반복 제거 |

## 실행 어라운드 패턴 vs try-with-resources

```java
// try-with-resources (Java 7+)
// - 단순한 자원 관리에 적합
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    return br.readLine();
}

// 실행 어라운드 패턴
// - 자원 관리 + 동작의 유연한 전달이 필요할 때
// - 같은 자원에 대해 다양한 작업을 수행할 때
processFile(br -> br.readLine());
processFile(br -> br.lines().count());
```

## 핵심 정리

1. **실행 어라운드 패턴**은 자원 설정/정리 코드가 실제 작업을 감싸는 형태
2. **람다**를 통해 실제 작업 부분만 유연하게 변경 가능
3. **4단계 구현**: 동작 파라미터화 → 함수형 인터페이스 정의 → 동작 실행 → 람다 전달
4. 데이터베이스 연결, 트랜잭션, 락, 파일 처리 등 자원 관리에 널리 활용
5. 코드 재사용성과 안전성을 동시에 확보할 수 있는 패턴
