# 함수형 인터페이스 (Functional Interface)

## 개념 정의

**함수형 인터페이스**는 **정확히 하나의 추상 메서드**를 가지는 인터페이스이다. 람다 표현식은 함수형 인터페이스의 추상 메서드 구현을 직접 전달하는 방식으로 동작한다.

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);  // 하나의 추상 메서드
}
```

## 핵심 규칙

> 디폴트 메서드나 정적 메서드가 여러 개 있어도, **추상 메서드가 오직 하나면** 함수형 인터페이스이다.

```java
@FunctionalInterface
public interface MyFunctionalInterface {
    // 추상 메서드 (오직 하나!)
    void execute();

    // 디폴트 메서드 (여러 개 가능)
    default void defaultMethod1() {
        System.out.println("Default 1");
    }

    default void defaultMethod2() {
        System.out.println("Default 2");
    }

    // 정적 메서드 (여러 개 가능)
    static void staticMethod() {
        System.out.println("Static method");
    }
}
```

## @FunctionalInterface 어노테이션

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}
```

### 역할
1. **문서화**: 해당 인터페이스가 함수형 인터페이스임을 명시
2. **컴파일 타임 검증**: 추상 메서드가 하나가 아니면 컴파일 에러 발생

### 컴파일 에러 예시
```java
@FunctionalInterface
public interface InvalidInterface {
    void method1();
    void method2();  // 컴파일 에러! 추상 메서드가 2개
}
```

## 함수 디스크립터 (Function Descriptor)

함수형 인터페이스의 추상 메서드 시그니처를 **함수 디스크립터**라고 한다. 람다 표현식의 시그니처를 서술하는 역할을 한다.

```java
// Predicate<T>의 함수 디스크립터: T -> boolean
Predicate<String> p = (String s) -> s.isEmpty();

// Consumer<T>의 함수 디스크립터: T -> void
Consumer<String> c = (String s) -> System.out.println(s);

// Function<T, R>의 함수 디스크립터: T -> R
Function<String, Integer> f = (String s) -> s.length();
```

## 대표적인 함수형 인터페이스

### Java 8 이전에도 있던 함수형 인터페이스

| 인터페이스 | 함수 디스크립터 | 용도 |
|-----------|----------------|------|
| Runnable | () -> void | 스레드 실행 |
| Callable\<V> | () -> V | 결과 반환하는 작업 |
| Comparator\<T> | (T, T) -> int | 객체 비교 |

### Java 8에서 추가된 주요 함수형 인터페이스

| 인터페이스 | 함수 디스크립터 | 용도 |
|-----------|----------------|------|
| Predicate\<T> | T -> boolean | 조건 검사 |
| Consumer\<T> | T -> void | 값 소비 |
| Function\<T, R> | T -> R | 값 변환 |
| Supplier\<T> | () -> T | 값 공급 |
| UnaryOperator\<T> | T -> T | 단항 연산 |
| BinaryOperator\<T> | (T, T) -> T | 이항 연산 |

## 람다와 함수형 인터페이스의 관계

람다 표현식 전체가 **함수형 인터페이스의 인스턴스로 취급**된다.

```java
// 람다 표현식은 Predicate 인터페이스의 인스턴스
Predicate<Apple> greenApple = (Apple a) -> GREEN.equals(a.getColor());

// 위 코드는 아래와 동일
Predicate<Apple> greenApple = new Predicate<Apple>() {
    @Override
    public boolean test(Apple a) {
        return GREEN.equals(a.getColor());
    }
};
```

## 사용자 정의 함수형 인터페이스

### 기본 형태
```java
@FunctionalInterface
public interface StringProcessor {
    String process(String input);
}

// 사용
StringProcessor toUpper = s -> s.toUpperCase();
StringProcessor addPrefix = s -> "PREFIX_" + s;

System.out.println(toUpper.process("hello"));     // "HELLO"
System.out.println(addPrefix.process("data"));    // "PREFIX_data"
```

### 제네릭 함수형 인터페이스
```java
@FunctionalInterface
public interface Transformer<T, R> {
    R transform(T input);
}

// 다양한 타입으로 사용
Transformer<String, Integer> strToInt = s -> Integer.parseInt(s);
Transformer<Integer, String> intToStr = i -> String.valueOf(i);
Transformer<List<String>, Integer> listSize = list -> list.size();
```

### 예외를 던지는 함수형 인터페이스
```java
@FunctionalInterface
public interface ThrowingFunction<T, R> {
    R apply(T t) throws Exception;
}

// 파일 읽기 예시
ThrowingFunction<String, String> readFile = path -> {
    return new String(Files.readAllBytes(Paths.get(path)));
};
```

## 함수형 인터페이스 조합

### 디폴트 메서드를 활용한 조합

```java
// Predicate 조합
Predicate<Apple> redApple = a -> RED.equals(a.getColor());
Predicate<Apple> heavyApple = a -> a.getWeight() > 150;

// AND 조합
Predicate<Apple> redAndHeavy = redApple.and(heavyApple);

// OR 조합
Predicate<Apple> redOrHeavy = redApple.or(heavyApple);

// NOT (부정)
Predicate<Apple> notRed = redApple.negate();
```

```java
// Function 조합
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> add10 = x -> x + 10;

// andThen: 먼저 실행 후 결과에 적용
Function<Integer, Integer> multiplyThenAdd = multiplyBy2.andThen(add10);
System.out.println(multiplyThenAdd.apply(5));  // (5 * 2) + 10 = 20

// compose: 파라미터 함수 먼저 실행
Function<Integer, Integer> addThenMultiply = multiplyBy2.compose(add10);
System.out.println(addThenMultiply.apply(5));  // (5 + 10) * 2 = 30
```

## 실전 활용 예제

### 1. 전략 패턴 대체
```java
// 기존 전략 패턴
interface ValidationStrategy {
    boolean execute(String s);
}

class IsNumeric implements ValidationStrategy {
    public boolean execute(String s) {
        return s.matches("\\d+");
    }
}

// 람다로 간소화
Predicate<String> isNumeric = s -> s.matches("\\d+");
Predicate<String> isAlphabetic = s -> s.matches("[a-zA-Z]+");
```

### 2. 콜백 구현
```java
@FunctionalInterface
interface Callback<T> {
    void onComplete(T result);
}

public void fetchData(Callback<String> callback) {
    String result = "Data from server";
    callback.onComplete(result);
}

// 사용
fetchData(data -> System.out.println("Received: " + data));
```

### 3. 팩토리 메서드
```java
@FunctionalInterface
interface Factory<T> {
    T create();
}

Factory<List<String>> listFactory = ArrayList::new;
List<String> newList = listFactory.create();
```

## 핵심 정리

1. **함수형 인터페이스**는 정확히 하나의 추상 메서드를 가진 인터페이스
2. **@FunctionalInterface** 어노테이션으로 의도를 명확히 하고 컴파일 타임 검증 가능
3. **디폴트 메서드**가 있어도 추상 메서드가 하나면 함수형 인터페이스
4. **함수 디스크립터**는 함수형 인터페이스의 추상 메서드 시그니처
5. 람다 표현식은 함수형 인터페이스의 **인스턴스로 취급**된다
6. java.util.function 패키지에 자주 사용하는 함수형 인터페이스가 정의되어 있다
