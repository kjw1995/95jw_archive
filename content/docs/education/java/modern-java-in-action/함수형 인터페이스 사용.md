# 함수형 인터페이스 사용

java.util.function 패키지에서 제공하는 다양한 함수형 인터페이스를 알아본다.

---

## 1. Predicate\<T>

### 정의
`T`를 인수로 받아 `boolean`을 반환하는 `test` 추상 메서드를 정의한다.

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

### 함수 디스크립터
```
T -> boolean
```

### 사용 예제
```java
// 비어있지 않은 문자열 검사
Predicate<String> nonEmpty = s -> !s.isEmpty();
System.out.println(nonEmpty.test("hello")); // true
System.out.println(nonEmpty.test(""));      // false

// 제네릭 필터 메서드 구현
public <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> results = new ArrayList<>();
    for (T t : list) {
        if (p.test(t)) {
            results.add(t);
        }
    }
    return results;
}

// 사용
List<String> strings = Arrays.asList("hello", "", "world", "");
List<String> nonEmptyStrings = filter(strings, s -> !s.isEmpty());
// 결과: ["hello", "world"]
```

### 조합 메서드
```java
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;

// AND 조합
Predicate<Integer> isPositiveAndEven = isPositive.and(isEven);
isPositiveAndEven.test(4);  // true
isPositiveAndEven.test(3);  // false

// OR 조합
Predicate<Integer> isPositiveOrEven = isPositive.or(isEven);
isPositiveOrEven.test(-2);  // true (짝수)
isPositiveOrEven.test(-3);  // false

// 부정 (negate)
Predicate<Integer> isNotPositive = isPositive.negate();
isNotPositive.test(-5);  // true
```

---

## 2. Consumer\<T>

### 정의
`T`를 인수로 받아 `void`를 반환하는 `accept` 추상 메서드를 정의한다.

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

### 함수 디스크립터
```
T -> void
```

### 사용 예제
```java
// 출력
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");  // "Hello" 출력

// forEach 구현
public <T> void forEach(List<T> list, Consumer<T> c) {
    for (T t : list) {
        c.accept(t);
    }
}

// 사용
forEach(Arrays.asList(1, 2, 3, 4, 5), i -> System.out.println(i));

// 객체 상태 변경
Consumer<StringBuilder> appendHello = sb -> sb.append("Hello");
StringBuilder sb = new StringBuilder();
appendHello.accept(sb);
System.out.println(sb);  // "Hello"
```

### 조합 메서드 (andThen)
```java
Consumer<String> print = s -> System.out.print(s);
Consumer<String> printLn = s -> System.out.println();

// 순차 실행
Consumer<String> printAndNewLine = print.andThen(printLn);
printAndNewLine.accept("Hello");  // "Hello" 출력 후 줄바꿈
```

---

## 3. Function\<T, R>

### 정의
`T`를 인수로 받아 `R`을 반환하는 `apply` 추상 메서드를 정의한다.

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

### 함수 디스크립터
```
T -> R
```

### 사용 예제
```java
// 문자열 길이 반환
Function<String, Integer> strLength = s -> s.length();
System.out.println(strLength.apply("hello"));  // 5

// map 구현
public <T, R> List<R> map(List<T> list, Function<T, R> f) {
    List<R> result = new ArrayList<>();
    for (T t : list) {
        result.add(f.apply(t));
    }
    return result;
}

// 사용
List<Integer> lengths = map(
    Arrays.asList("lambdas", "in", "action"),
    s -> s.length()
);
// 결과: [7, 2, 6]
```

### 조합 메서드
```java
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> add10 = x -> x + 10;

// andThen: 현재 함수 실행 후 인수 함수 실행
Function<Integer, Integer> multiplyThenAdd = multiplyBy2.andThen(add10);
System.out.println(multiplyThenAdd.apply(3));  // (3 * 2) + 10 = 16

// compose: 인수 함수 먼저 실행 후 현재 함수 실행
Function<Integer, Integer> addThenMultiply = multiplyBy2.compose(add10);
System.out.println(addThenMultiply.apply(3));  // (3 + 10) * 2 = 26

// identity: 항등 함수
Function<String, String> identity = Function.identity();
identity.apply("hello");  // "hello"
```

---

## 4. Supplier\<T>

### 정의
인수 없이 `T`를 반환하는 `get` 추상 메서드를 정의한다.

```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

### 함수 디스크립터
```
() -> T
```

### 사용 예제
```java
// 객체 생성
Supplier<Apple> appleSupplier = () -> new Apple();
Apple apple = appleSupplier.get();

// 랜덤 값 생성
Supplier<Double> randomSupplier = () -> Math.random();
System.out.println(randomSupplier.get());  // 0.xxxx...

// 지연 초기화 (Lazy Initialization)
public class LazyValue<T> {
    private T value;
    private final Supplier<T> supplier;

    public LazyValue(Supplier<T> supplier) {
        this.supplier = supplier;
    }

    public T get() {
        if (value == null) {
            value = supplier.get();
        }
        return value;
    }
}

// 사용
LazyValue<ExpensiveObject> lazy = new LazyValue<>(() -> new ExpensiveObject());
// 실제 get() 호출 시점에 객체 생성
```

---

## 5. UnaryOperator\<T>

### 정의
`Function<T, T>`의 특수 형태로, 입력과 출력 타입이 같다.

```java
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}
```

### 함수 디스크립터
```
T -> T
```

### 사용 예제
```java
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(5));  // 25

UnaryOperator<String> toUpper = s -> s.toUpperCase();
System.out.println(toUpper.apply("hello"));  // "HELLO"

// List의 replaceAll과 함께 사용
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.replaceAll(n -> n * 2);  // [2, 4, 6, 8, 10]
```

---

## 6. BinaryOperator\<T>

### 정의
`BiFunction<T, T, T>`의 특수 형태로, 두 개의 같은 타입 인수를 받아 같은 타입을 반환한다.

```java
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
}
```

### 함수 디스크립터
```
(T, T) -> T
```

### 사용 예제
```java
BinaryOperator<Integer> add = (a, b) -> a + b;
System.out.println(add.apply(3, 4));  // 7

BinaryOperator<String> concat = (a, b) -> a + b;
System.out.println(concat.apply("Hello", " World"));  // "Hello World"

// reduce와 함께 사용
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
// 결과: 15
```

---

## 7. BiPredicate\<T, U>

### 정의
두 개의 인수를 받아 `boolean`을 반환한다.

```java
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}
```

### 함수 디스크립터
```
(T, U) -> boolean
```

### 사용 예제
```java
BiPredicate<String, Integer> checkLength = (s, len) -> s.length() == len;
System.out.println(checkLength.test("hello", 5));  // true
System.out.println(checkLength.test("hello", 3));  // false

BiPredicate<List<?>, Integer> hasSize = (list, size) -> list.size() >= size;
```

---

## 8. BiConsumer\<T, U>

### 정의
두 개의 인수를 받아 `void`를 반환한다.

```java
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
```

### 함수 디스크립터
```
(T, U) -> void
```

### 사용 예제
```java
BiConsumer<String, Integer> printNTimes = (s, n) -> {
    for (int i = 0; i < n; i++) {
        System.out.println(s);
    }
};
printNTimes.accept("Hello", 3);  // "Hello" 3번 출력

// Map의 forEach와 함께 사용
Map<String, Integer> map = new HashMap<>();
map.put("a", 1);
map.put("b", 2);
map.forEach((k, v) -> System.out.println(k + " = " + v));
```

---

## 9. BiFunction\<T, U, R>

### 정의
두 개의 인수(`T`, `U`)를 받아 `R`을 반환한다.

```java
@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
}
```

### 함수 디스크립터
```
(T, U) -> R
```

### 사용 예제
```java
BiFunction<String, String, Integer> compare = (a, b) -> a.compareTo(b);
System.out.println(compare.apply("apple", "banana"));  // 음수

BiFunction<Integer, Integer, String> combine = (a, b) -> a + "+" + b + "=" + (a + b);
System.out.println(combine.apply(3, 5));  // "3+5=8"
```

---

## 기본형 특화 (Primitive Specialization)

### 박싱/언박싱 비용 문제
```java
// 오토박싱 발생 - 성능 저하
Predicate<Integer> isEven = i -> i % 2 == 0;

// 기본형 특화 - 박싱 없음
IntPredicate isEvenPrimitive = i -> i % 2 == 0;
```

> **박싱(Boxing)**: 기본형 → 참조형 변환
> **언박싱(Unboxing)**: 참조형 → 기본형 변환
> 변환 과정에서 메모리 할당과 탐색 비용 발생

### 기본형 특화 인터페이스

| 일반 인터페이스 | 기본형 특화 버전 |
|---------------|------------------|
| Predicate\<T> | IntPredicate, LongPredicate, DoublePredicate |
| Consumer\<T> | IntConsumer, LongConsumer, DoubleConsumer |
| Function\<T,R> | IntFunction\<R>, LongFunction\<R>, DoubleFunction\<R>, ToIntFunction\<T>, ToLongFunction\<T>, ToDoubleFunction\<T>, IntToLongFunction, IntToDoubleFunction, LongToIntFunction, LongToDoubleFunction, DoubleToIntFunction, DoubleToLongFunction |
| Supplier\<T> | IntSupplier, LongSupplier, DoubleSupplier, BooleanSupplier |
| UnaryOperator\<T> | IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator |
| BinaryOperator\<T> | IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator |
| BiConsumer\<T,U> | ObjIntConsumer\<T>, ObjLongConsumer\<T>, ObjDoubleConsumer\<T> |
| BiFunction\<T,U,R> | ToIntBiFunction\<T,U>, ToLongBiFunction\<T,U>, ToDoubleBiFunction\<T,U> |

### 기본형 특화 사용 예제
```java
// IntPredicate
IntPredicate isPositive = n -> n > 0;
isPositive.test(5);  // true (박싱 없음)

// IntConsumer
IntConsumer printInt = System.out::println;
printInt.accept(42);

// IntFunction<R>
IntFunction<String> intToString = i -> "Number: " + i;
intToString.apply(10);  // "Number: 10"

// ToIntFunction<T>
ToIntFunction<String> strLen = String::length;
strLen.applyAsInt("hello");  // 5

// IntUnaryOperator
IntUnaryOperator doubleIt = n -> n * 2;
doubleIt.applyAsInt(5);  // 10

// IntBinaryOperator
IntBinaryOperator add = (a, b) -> a + b;
add.applyAsInt(3, 4);  // 7

// IntSupplier
IntSupplier randomInt = () -> (int) (Math.random() * 100);
randomInt.getAsInt();
```

---

## 함수형 인터페이스 선택 가이드

```
입력이 없는가?
  ├─ 예 → 반환값이 있는가?
  │        ├─ 예 → Supplier<T>
  │        └─ 아니오 → Runnable
  └─ 아니오 → 입력이 1개인가?
             ├─ 예 → 반환값이 있는가?
             │        ├─ boolean → Predicate<T>
             │        ├─ 입력과 같은 타입 → UnaryOperator<T>
             │        ├─ void → Consumer<T>
             │        └─ 다른 타입 → Function<T, R>
             └─ 아니오 (2개) → 반환값이 있는가?
                      ├─ boolean → BiPredicate<T, U>
                      ├─ 입력과 같은 타입 → BinaryOperator<T>
                      ├─ void → BiConsumer<T, U>
                      └─ 다른 타입 → BiFunction<T, U, R>
```

---

## 핵심 정리

1. **Predicate**: 조건 검사 (T → boolean)
2. **Consumer**: 값 소비, 부수 효과 (T → void)
3. **Function**: 값 변환 (T → R)
4. **Supplier**: 값 생성 (() → T)
5. **Operator**: 같은 타입의 입출력 (UnaryOperator, BinaryOperator)
6. **Bi-** 접두사: 두 개의 인수를 받는 버전
7. **기본형 특화**: 박싱/언박싱 비용을 피하기 위한 Int/Long/Double 버전 사용
