---
title: DBMS 개요
weight: 2
---

## 파일 시스템 vs DBMS

```
┌─────────────────────────────────────────────────────────────────────┐
│                       파일 시스템 (File System)                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   응용 프로그램 A ──→ 파일 A (고객 정보)                             │
│                                                                      │
│   응용 프로그램 B ──→ 파일 B (고객 정보 + 주문)  ← 데이터 중복!      │
│                                                                      │
│   응용 프로그램 C ──→ 파일 C (고객 정보 + 배송)  ← 데이터 중복!      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                            DBMS                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   응용 프로그램 A ──┐                                                │
│                     │      ┌──────────────────┐                     │
│   응용 프로그램 B ──┼──→   │      DBMS        │ ──→ 통합 DB         │
│                     │      └──────────────────┘                     │
│   응용 프로그램 C ──┘                                                │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 파일 시스템의 4가지 문제점

| 문제점 | 설명 | 예시 |
|--------|------|------|
| **데이터 중복성** | 같은 데이터가 여러 파일에 저장 | 고객 정보가 A, B, C 파일에 각각 존재 |
| **데이터 종속성** | 파일 구조 변경 시 프로그램도 수정 필요 | 필드 추가 → 모든 프로그램 수정 |
| **동시 공유 불가** | 하나의 파일에 동시 접근 어려움 | 여러 사용자 동시 수정 불가 |
| **보안/회복 부족** | 파일 단위 권한만 제공, 장애 회복 어려움 | 세부 데이터 접근 제어 불가 |

```
데이터 중복성 문제
─────────────────────────────────────────────────────
파일 A: 고객명="홍길동", 연락처="010-1234-5678"
파일 B: 고객명="홍길동", 연락처="010-9999-0000" ← 불일치!

→ 데이터 일관성(Consistency) 위반
→ 데이터 무결성(Integrity) 유지 어려움
```

---

## DBMS의 정의

> **DBMS (Database Management System)**
> 데이터베이스를 생성, 관리하고 응용 프로그램의 데이터 처리 요청을 중개하는 소프트웨어

```
┌───────────────────────────────────────────────────────────────┐
│                         사용자                                 │
│     (DBA / 응용 프로그래머 / 최종 사용자)                      │
└───────────────────────┬───────────────────────────────────────┘
                        │ 요청 (SQL)
                        ▼
┌───────────────────────────────────────────────────────────────┐
│                         DBMS                                   │
│  ┌─────────────────┐  ┌─────────────────────────────────────┐│
│  │   질의 처리기    │  │         저장 데이터 관리자          ││
│  │ (Query Processor)│  │   (Stored Data Manager)            ││
│  └─────────────────┘  └─────────────────────────────────────┘│
└───────────────────────┬───────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│                     데이터베이스                               │
│            (데이터 + 메타데이터/데이터 사전)                   │
└───────────────────────────────────────────────────────────────┘
```

### DBMS 3가지 핵심 기능

| 기능 | 설명 | SQL 예시 |
|------|------|----------|
| **정의 기능 (DDL)** | DB 구조 정의/수정/삭제 | `CREATE`, `ALTER`, `DROP` |
| **조작 기능 (DML)** | 데이터 삽입/삭제/수정/검색 | `INSERT`, `DELETE`, `UPDATE`, `SELECT` |
| **제어 기능 (DCL)** | 무결성, 보안, 동시성, 회복 | `GRANT`, `REVOKE`, `COMMIT`, `ROLLBACK` |

#### DDL 예제 (Data Definition Language)

```sql
-- 테이블 생성
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 테이블 구조 변경
ALTER TABLE customers ADD phone VARCHAR(20);

-- 테이블 삭제
DROP TABLE customers;
```

#### DML 예제 (Data Manipulation Language)

```sql
-- 삽입
INSERT INTO customers (id, name, email)
VALUES (1, '홍길동', 'hong@example.com');

-- 검색
SELECT * FROM customers WHERE name = '홍길동';

-- 수정
UPDATE customers SET email = 'new@example.com' WHERE id = 1;

-- 삭제
DELETE FROM customers WHERE id = 1;
```

#### DCL 예제 (Data Control Language)

```sql
-- 권한 부여
GRANT SELECT, INSERT ON customers TO 'user1';

-- 권한 회수
REVOKE INSERT ON customers FROM 'user1';

-- 트랜잭션 제어
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 10000 WHERE id = 1;
UPDATE accounts SET balance = balance + 10000 WHERE id = 2;
COMMIT;  -- 성공 시 확정
-- ROLLBACK;  -- 실패 시 취소
```

---

## 스키마와 인스턴스

```
┌─────────────────────────────────────────────────────────────┐
│  스키마 (Schema) - 데이터베이스의 구조와 제약조건 정의       │
├─────────────────────────────────────────────────────────────┤
│  CREATE TABLE employees (                                    │
│      id INT PRIMARY KEY,                                     │
│      name VARCHAR(50) NOT NULL,                              │
│      salary DECIMAL(10,2) CHECK (salary > 0)                │
│  );                                                          │
└─────────────────────────────────────────────────────────────┘
                        │
                        ▼ 스키마에 따라 저장
┌─────────────────────────────────────────────────────────────┐
│  인스턴스 (Instance) - 특정 시점의 실제 데이터 값            │
├─────────────────────────────────────────────────────────────┤
│  | id | name   | salary     |                               │
│  |----|--------|------------|                               │
│  | 1  | 홍길동  | 50000.00   |                               │
│  | 2  | 김철수  | 45000.00   |                               │
│  | 3  | 이영희  | 55000.00   |                               │
└─────────────────────────────────────────────────────────────┘
```

| 구분 | 스키마 (Schema) | 인스턴스 (Instance) |
|------|----------------|---------------------|
| 성격 | 정적 (거의 변하지 않음) | 동적 (자주 변함) |
| 내용 | 구조, 제약조건 | 실제 데이터 값 |
| 정의 | DDL로 정의 | DML로 조작 |

---

## 3단계 데이터베이스 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                        외부 단계 (External Level)                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 외부 스키마 1 │  │ 외부 스키마 2 │  │ 외부 스키마 3 │          │
│  │ (사용자 A뷰)  │  │ (사용자 B뷰)  │  │ (앱 C 뷰)    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│         │                 │                 │                   │
├─────────┴─────────────────┴─────────────────┴───────────────────┤
│                  외부/개념 사상 (논리적 데이터 독립성)            │
├─────────────────────────────────────────────────────────────────┤
│                        개념 단계 (Conceptual Level)              │
│                   ┌─────────────────────┐                       │
│                   │     개념 스키마      │                       │
│                   │ (전체 DB 논리 구조)  │                       │
│                   └─────────────────────┘                       │
├─────────────────────────────────────────────────────────────────┤
│                  개념/내부 사상 (물리적 데이터 독립성)            │
├─────────────────────────────────────────────────────────────────┤
│                        내부 단계 (Internal Level)                │
│                   ┌─────────────────────┐                       │
│                   │     내부 스키마      │                       │
│                   │ (물리적 저장 구조)   │                       │
│                   └─────────────────────┘                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   저장 장치      │
                    │  (HDD/SSD)      │
                    └─────────────────┘
```

### 3단계 구조 상세

| 단계 | 스키마 | 관점 | 개수 | 설명 |
|------|--------|------|------|------|
| **외부 단계** | 외부 스키마 | 개별 사용자 | 여러 개 | 사용자별 필요한 데이터만 정의 (View) |
| **개념 단계** | 개념 스키마 | 조직 전체 | 1개 | 전체 DB의 논리적 구조 정의 |
| **내부 단계** | 내부 스키마 | 저장 장치 | 1개 | 물리적 저장 방법 정의 |

#### 외부 스키마 예제 (View)

```sql
-- 개념 스키마: 전체 테이블
CREATE TABLE employees (
    id INT, name VARCHAR(50), salary DECIMAL, ssn VARCHAR(20)
);

-- 외부 스키마 1: 인사팀용 (전체 접근)
CREATE VIEW hr_view AS
SELECT id, name, salary, ssn FROM employees;

-- 외부 스키마 2: 일반 직원용 (급여, 주민번호 숨김)
CREATE VIEW employee_view AS
SELECT id, name FROM employees;
```

---

## 데이터 독립성

### 논리적 데이터 독립성

> 개념 스키마가 변경되어도 외부 스키마(응용 프로그램)에 영향 없음

```sql
-- 개념 스키마 변경: 컬럼 추가
ALTER TABLE employees ADD department VARCHAR(50);

-- 외부 스키마(View)는 변경 불필요 → 기존 앱 정상 작동
SELECT * FROM employee_view;  -- 여전히 동작
```

### 물리적 데이터 독립성

> 내부 스키마가 변경되어도 개념 스키마에 영향 없음

```
예: 저장 장치를 HDD → SSD로 변경
    인덱스 추가/삭제
    파티셔닝 방식 변경

→ 논리적 테이블 구조는 그대로 유지
→ 응용 프로그램 수정 불필요
```

---

## DBMS 장단점

### 장점

| 장점 | 설명 |
|------|------|
| **데이터 중복 통제** | 통합 관리로 중복 최소화 |
| **데이터 독립성** | DB 구조 변경 시 앱 영향 최소화 |
| **동시 공유** | 여러 사용자 동시 접근 지원 |
| **보안 향상** | 세분화된 접근 제어 가능 |
| **무결성 유지** | 제약조건으로 데이터 정확성 보장 |
| **표준화** | 데이터 접근 방법 통일 (SQL) |
| **장애 회복** | 트랜잭션 로그로 복구 가능 |

### 단점

| 단점 | 설명 |
|------|------|
| **높은 비용** | 라이선스, 하드웨어, 운영 비용 |
| **복잡한 백업/회복** | 대용량 데이터 관리 복잡 |
| **단일 장애점** | DBMS 장애 시 전체 시스템 영향 |

---

## DBMS 발전 과정

```
┌─────────────────────────────────────────────────────────────────┐
│ 1세대 (1960s)      │ 2세대 (1970s~)    │ 3세대 (1980s~)         │
│ 네트워크/계층 DBMS  │ 관계 DBMS         │ 객체지향/객체관계 DBMS  │
├────────────────────┼───────────────────┼────────────────────────┤
│ IDS, IMS           │ Oracle, MySQL     │ ObjectStore            │
│                    │ PostgreSQL, MSSQL │ PostgreSQL (확장)      │
├────────────────────┴───────────────────┴────────────────────────┤
│ 4세대 (2000s~)                                                   │
│ NoSQL / NewSQL DBMS                                              │
├─────────────────────────────────────────────────────────────────┤
│ MongoDB, Redis, Cassandra (NoSQL)                                │
│ CockroachDB, TiDB, Spanner (NewSQL)                              │
└─────────────────────────────────────────────────────────────────┘
```

### 세대별 비교

| 세대 | DBMS 유형 | 데이터 모델 | 특징 | 대표 제품 |
|------|----------|-------------|------|-----------|
| **1세대** | 네트워크/계층 | 그래프/트리 | 구조 변경 어려움 | IDS, IMS |
| **2세대** | 관계형 (RDBMS) | 테이블 | SQL 사용, 단순한 구조 | Oracle, MySQL |
| **3세대** | 객체지향/객체관계 | 객체 | 복잡한 데이터 표현 | ObjectStore |
| **4세대** | NoSQL | 다양함 | 확장성, 유연성 | MongoDB, Redis |
| **4세대** | NewSQL | 테이블 | SQL + 확장성 | CockroachDB |

### NoSQL vs RDBMS vs NewSQL

```
┌────────────────────────────────────────────────────────────────┐
│                        RDBMS                                    │
│  - 정형 데이터에 적합                                           │
│  - ACID 보장 (일관성, 안정성)                                   │
│  - 수직 확장 (Scale-up)                                         │
│  - SQL 지원                                                     │
├────────────────────────────────────────────────────────────────┤
│                        NoSQL                                    │
│  - 비정형/반정형 데이터에 적합                                  │
│  - BASE (가용성, 유연성 우선)                                   │
│  - 수평 확장 (Scale-out)                                        │
│  - 스키마 없음 (Schema-less)                                    │
├────────────────────────────────────────────────────────────────┤
│                        NewSQL                                   │
│  - RDBMS 장점 + NoSQL 확장성                                    │
│  - ACID 보장 + 분산 처리                                        │
│  - SQL 지원 + 수평 확장                                         │
└────────────────────────────────────────────────────────────────┘
```

---

## 데이터베이스 사용자

```
┌─────────────────────────────────────────────────────────────────┐
│                     데이터베이스 사용자                          │
├──────────────────┬──────────────────┬───────────────────────────┤
│       DBA        │   응용 프로그래머  │      최종 사용자          │
│ (관리자)         │  (Developer)      │   (End User)             │
├──────────────────┼──────────────────┼───────────────────────────┤
│ - DB 설계/운영    │ - 응용 프로그램   │ - 데이터 조회/수정        │
│ - 보안 관리       │   개발            │ - GUI/웹 통해 접근        │
│ - 성능 튜닝       │ - SQL 임베딩      │                          │
│ - 백업/복구       │                   │                          │
└──────────────────┴──────────────────┴───────────────────────────┘
```

---

## 데이터 사전 (시스템 카탈로그)

> **메타데이터(데이터에 대한 데이터)**를 저장하는 시스템 DB

```sql
-- MySQL: 시스템 카탈로그 조회
SELECT * FROM information_schema.tables
WHERE table_schema = 'mydb';

SELECT * FROM information_schema.columns
WHERE table_name = 'employees';

-- PostgreSQL
SELECT * FROM pg_catalog.pg_tables;

-- Oracle
SELECT * FROM user_tables;
SELECT * FROM user_tab_columns WHERE table_name = 'EMPLOYEES';
```

### 데이터 사전이 저장하는 정보

| 정보 유형 | 예시 |
|----------|------|
| 테이블 정보 | 테이블명, 생성일, 소유자 |
| 컬럼 정보 | 컬럼명, 데이터타입, 제약조건 |
| 인덱스 정보 | 인덱스명, 대상 컬럼 |
| 사용자 정보 | 사용자명, 권한 |
| 뷰 정보 | 뷰 이름, 정의 쿼리 |

---

## 트랜잭션과 ACID

> **트랜잭션**: 하나의 논리적 작업 단위를 구성하는 연산들의 집합

```sql
-- 계좌 이체 트랜잭션 예제
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 50000
WHERE account_id = 'A';  -- A 계좌에서 출금

UPDATE accounts SET balance = balance + 50000
WHERE account_id = 'B';  -- B 계좌에 입금

COMMIT;  -- 모두 성공 시 확정
-- ROLLBACK;  -- 하나라도 실패 시 전체 취소
```

### ACID 특성

| 특성 | 설명 | 예시 |
|------|------|------|
| **Atomicity (원자성)** | 전부 수행 or 전부 취소 | 이체 중 오류 → 전체 롤백 |
| **Consistency (일관성)** | 트랜잭션 전후 DB 일관성 유지 | 이체 후 총액 동일 |
| **Isolation (격리성)** | 동시 트랜잭션 간 간섭 없음 | 다른 이체와 독립 실행 |
| **Durability (지속성)** | 완료된 트랜잭션 결과 영구 보존 | 시스템 장애 후에도 유지 |

---

## 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| **DBMS** | 데이터베이스 관리 시스템 |
| **스키마** | DB 구조와 제약조건 정의 |
| **인스턴스** | 특정 시점의 실제 데이터 |
| **DDL** | 데이터 정의어 (CREATE, ALTER, DROP) |
| **DML** | 데이터 조작어 (SELECT, INSERT, UPDATE, DELETE) |
| **DCL** | 데이터 제어어 (GRANT, REVOKE) |
| **TCL** | 트랜잭션 제어어 (COMMIT, ROLLBACK) |
| **데이터 독립성** | DB 구조 변경 시 앱 영향 최소화 |
| **데이터 사전** | 메타데이터 저장소 (시스템 카탈로그) |
| **ACID** | 트랜잭션의 4가지 특성 |
| **NoSQL** | 비관계형 데이터베이스 |
| **NewSQL** | 관계형 + NoSQL 장점 결합 |
