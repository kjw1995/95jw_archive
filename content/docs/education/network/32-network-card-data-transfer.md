---
title: "랜카드에서의 데이터 전달과 처리"
weight: 32
---

# 32. 랜카드에서의 데이터 전달과 처리

컴퓨터에서 웹 브라우저를 이용하여 웹 서버에 접속할 때, 데이터는 OSI 모델의 각 계층을 거치면서 캡슐화되어 최종적으로 전기 신호로 변환됩니다. 이 과정을 상세히 살펴보겠습니다.

## 32-1. 네트워크의 구성 (OSI 7계층)

OSI 모델의 각 계층은 특정한 역할을 담당합니다:

```
┌─────────────────────────────────────────────────────────────┐
│                     OSI 7계층 구조                           │
├───────┬─────────────────┬──────────────────────────────────┤
│ 계층   │ 이름            │ 역할                              │
├───────┼─────────────────┼──────────────────────────────────┤
│ 7계층  │ 응용 계층       │ 애플리케이션에서 사용하는 데이터  │
│        │ (Application)   │ 송수신 (HTTP, FTP, SMTP, DNS)    │
├───────┼─────────────────┼──────────────────────────────────┤
│ 6계층  │ 표현 계층       │ 데이터 형식 변환, 암호화, 압축    │
│        │ (Presentation)  │ (JPEG, MPEG, SSL/TLS)            │
├───────┼─────────────────┼──────────────────────────────────┤
│ 5계층  │ 세션 계층       │ 세션 연결, 유지, 종료             │
│        │ (Session)       │ (NetBIOS, RPC)                   │
├───────┼─────────────────┼──────────────────────────────────┤
│ 4계층  │ 전송 계층       │ 목적지에 데이터를 정확하게 전달   │
│        │ (Transport)     │ (TCP, UDP)                       │
├───────┼─────────────────┼──────────────────────────────────┤
│ 3계층  │ 네트워크 계층   │ 다른 네트워크로 데이터 전달       │
│        │ (Network)       │ (IP, ICMP, ARP)                  │
├───────┼─────────────────┼──────────────────────────────────┤
│ 2계층  │ 데이터링크 계층 │ 같은 네트워크(LAN)에서 데이터     │
│        │ (Data Link)     │ 송수신 (Ethernet, MAC)           │
├───────┼─────────────────┼──────────────────────────────────┤
│ 1계층  │ 물리 계층       │ 데이터를 전기 신호로 변환         │
│        │ (Physical)      │ (랜카드, 케이블, 허브)            │
└───────┴─────────────────┴──────────────────────────────────┘
```

### TCP/IP 모델과의 비교

실제 인터넷에서는 OSI 7계층 대신 TCP/IP 4계층 모델을 주로 사용합니다:

```
OSI 7계층                     TCP/IP 4계층
┌──────────────────┐
│  응용 계층 (7)    │
├──────────────────┤          ┌──────────────────┐
│  표현 계층 (6)    │          │                  │
├──────────────────┤    →     │  응용 계층       │
│  세션 계층 (5)    │          │  (Application)   │
├──────────────────┤          └──────────────────┘
│  전송 계층 (4)    │    →     ┌──────────────────┐
├──────────────────┤          │  전송 계층       │
│  네트워크 계층 (3)│          │  (Transport)     │
├──────────────────┤          └──────────────────┘
│ 데이터링크 계층(2)│    →     ┌──────────────────┐
├──────────────────┤          │  인터넷 계층     │
│  물리 계층 (1)    │          │  (Internet)      │
└──────────────────┘          └──────────────────┘
                              ┌──────────────────┐
                              │  네트워크         │
                              │  인터페이스 계층  │
                              │  (Network Access)│
                              └──────────────────┘
```

---

## 32-2. 컴퓨터의 데이터가 전기 신호로 변환되는 과정

### 전체 캡슐화 과정 개요

웹 브라우저에서 웹 서버로 요청을 보낼 때, 데이터는 다음과 같이 캡슐화됩니다:

```
[응용 계층]
   데이터: GET /index.html HTTP/1.1
   ↓
[전송 계층]
   TCP 헤더 + 데이터 = 세그먼트 (Segment)
   ↓
[네트워크 계층]
   IP 헤더 + 세그먼트 = IP 패킷 (Packet)
   ↓
[데이터링크 계층]
   이더넷 헤더 + IP 패킷 + FCS = 이더넷 프레임 (Frame)
   ↓
[물리 계층]
   전기 신호로 변환 → 네트워크 전송
```

### 단계별 상세 설명

#### 1단계: 응용 계층 (Application Layer)

사용자가 웹 브라우저를 이용하여 웹 서버에 접속하려고 합니다. 이때 HTTP 프로토콜을 사용합니다.

```
┌─────────────────────────────────────────────────────────┐
│              응용 계층 - HTTP 메시지                     │
├─────────────────────────────────────────────────────────┤
│ GET /index.html HTTP/1.1                                │
│ Host: www.example.com                                   │
│ User-Agent: Mozilla/5.0                                 │
│ Accept: text/html                                       │
│ Accept-Language: ko-KR                                  │
│ Connection: keep-alive                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**HTTP 요청 구조:**
```
GET /index.html HTTP/1.1          ← 요청 라인 (메서드, URI, 버전)
Host: www.example.com             ← 헤더 (여러 줄)
User-Agent: Mozilla/5.0
...
                                  ← 빈 줄
(메시지 본문, 있는 경우)           ← 본문 (POST 등에서 사용)
```

#### 2단계: 전송 계층 (Transport Layer) - TCP 헤더 추가

전송 계층에서 TCP 헤더가 추가됩니다. 이때 만들어진 데이터를 **세그먼트(Segment)**라고 합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    TCP 헤더 (20바이트)                       │
├───────────────────┬─────────────────────────────────────────┤
│ 출발지 포트 (16비트)│ 목적지 포트 (16비트)                    │
│ 예: 54321          │ 예: 80 (HTTP)                           │
├───────────────────────────────────────────────────────────┤
│ 시퀀스 번호 (Sequence Number) - 32비트                     │
│ 예: 1000                                                  │
├───────────────────────────────────────────────────────────┤
│ 확인 응답 번호 (Acknowledgment Number) - 32비트           │
│ 예: 5000                                                  │
├───────┬───┬─────────────────┬──────────────────────────────┤
│헤더길이│예약│플래그 (9비트)   │윈도우 크기 (16비트)          │
│4비트  │3비트│ACK, SYN, FIN 등│예: 65535                     │
├───────────────────┬──────────────────────────────────────┤
│체크섬 (16비트)     │긴급 포인터 (16비트)                   │
├───────────────────────────────────────────────────────────┤
│옵션 (가변, 최대 40바이트)                                  │
├───────────────────────────────────────────────────────────┤
│                                                           │
│             데이터 (HTTP 메시지)                           │
│         GET /index.html HTTP/1.1                          │
│         Host: www.example.com                             │
│         ...                                               │
│                                                           │
└───────────────────────────────────────────────────────────┘

이 전체를 세그먼트 (Segment) 라고 부릅니다.
```

**TCP 헤더 주요 필드:**

```
출발지 포트 번호:
├─ 클라이언트가 사용하는 포트
├─ 동적 포트 (1024-65535) 중 무작위 선택
└─ 예: 54321

목적지 포트 번호:
├─ 서버 애플리케이션의 포트
├─ Well-Known Port 사용
└─ HTTP: 80, HTTPS: 443, FTP: 21, SSH: 22

시퀀스 번호:
├─ 전송하는 데이터의 순서 번호
├─ 데이터 재조립에 사용
└─ 초기값은 무작위로 선택 (보안)

확인 응답 번호:
├─ 다음에 받을 것으로 기대되는 바이트 번호
├─ "여기까지 잘 받았어요" 의미
└─ ACK 플래그와 함께 사용

플래그:
├─ SYN: 연결 시작
├─ ACK: 확인 응답
├─ FIN: 연결 종료
├─ RST: 연결 재설정
├─ PSH: 즉시 전달
└─ URG: 긴급 데이터

윈도우 크기:
├─ 수신 버퍼의 여유 공간
├─ 흐름 제어에 사용
└─ 단위: 바이트
```

**포트 번호 선택:**

출발지 포트 번호는 Well-Known Port(0-1023)가 아닌 동적 포트(1024-65535) 중에서 무작위로 선택됩니다:

```bash
# 현재 사용 중인 포트 확인 (Linux)
netstat -an | grep ESTABLISHED

# 예시 출력
tcp  0  0  192.168.0.10:54321  93.184.216.34:80  ESTABLISHED
              ↑                      ↑
           출발지 포트            목적지 포트
          (동적 선택)            (HTTP 80)
```

#### 3단계: 네트워크 계층 (Network Layer) - IP 헤더 추가

네트워크 계층에서 IP 헤더가 추가됩니다. 이때 만들어진 데이터를 **IP 패킷(IP Packet)**이라고 합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    IPv4 헤더 (20바이트)                      │
├───────┬───────┬───────────────────────────────────────────┤
│버전   │헤더길이│서비스 유형 (TOS)│전체 길이 (16비트)       │
│4비트  │4비트  │8비트           │예: 1500바이트            │
├───────────────────────────┬───────────────────────────────┤
│식별자 (16비트)             │플래그│단편화 오프셋 (13비트)   │
│예: 12345                  │3비트│0                         │
├───────────────────┬───────────────────────────────────────┤
│TTL (8비트)        │프로토콜 (8비트)│헤더 체크섬 (16비트)     │
│예: 64             │예: 6 (TCP)    │                         │
├───────────────────────────────────────────────────────────┤
│출발지 IP 주소 (32비트)                                      │
│예: 192.168.0.10                                            │
├───────────────────────────────────────────────────────────┤
│목적지 IP 주소 (32비트)                                      │
│예: 93.184.216.34 (example.com)                            │
├───────────────────────────────────────────────────────────┤
│옵션 (가변, 최대 40바이트)                                   │
├───────────────────────────────────────────────────────────┤
│                                                           │
│             데이터 (TCP 세그먼트)                          │
│         ┌─────────────────────────┐                       │
│         │ TCP 헤더                │                       │
│         ├─────────────────────────┤                       │
│         │ HTTP 메시지             │                       │
│         └─────────────────────────┘                       │
│                                                           │
└───────────────────────────────────────────────────────────┘

이 전체를 IP 패킷 (IP Packet) 이라고 부릅니다.
```

**IP 헤더 주요 필드:**

```
버전 (Version):
├─ IP 버전 번호
├─ IPv4: 4
└─ IPv6: 6

헤더 길이 (IHL - Internet Header Length):
├─ IP 헤더 길이
├─ 단위: 4바이트 (워드)
└─ 기본: 5 (20바이트)

전체 길이 (Total Length):
├─ IP 헤더 + 데이터의 총 길이
├─ 단위: 바이트
└─ 최대: 65535 바이트

TTL (Time To Live):
├─ 패킷의 수명
├─ 라우터를 거칠 때마다 1씩 감소
├─ 0이 되면 패킷 폐기
└─ 무한 루프 방지

프로토콜 (Protocol):
├─ 상위 계층 프로토콜 식별
├─ 1: ICMP
├─ 6: TCP
├─ 17: UDP
└─ 41: IPv6

출발지 IP 주소:
├─ 송신자의 IP 주소
└─ 예: 192.168.0.10 (내 컴퓨터)

목적지 IP 주소:
├─ 수신자의 IP 주소
└─ 예: 93.184.216.34 (example.com)
```

#### 4단계: 데이터링크 계층 (Data Link Layer) - 이더넷 헤더 추가

데이터링크 계층에서 이더넷 헤더와 트레일러(FCS)가 추가됩니다. 이때 만들어진 데이터를 **이더넷 프레임(Ethernet Frame)**이라고 합니다.

```
┌─────────────────────────────────────────────────────────────┐
│            이더넷 헤더 (14바이트)                            │
├───────────────────────────────────────────────────────────┤
│목적지 MAC 주소 (6바이트)                                    │
│예: 00:1A:2B:3C:4D:5E (웹 서버의 MAC 또는 게이트웨이)       │
├───────────────────────────────────────────────────────────┤
│출발지 MAC 주소 (6바이트)                                    │
│예: AA:BB:CC:DD:EE:FF (내 컴퓨터의 랜카드)                  │
├───────────────────────────────────────────────────────────┤
│이더넷 타입 (2바이트)                                        │
│예: 0x0800 (IPv4), 0x0806 (ARP), 0x86DD (IPv6)             │
├───────────────────────────────────────────────────────────┤
│                                                           │
│             데이터 (IP 패킷)                               │
│         ┌─────────────────────────┐                       │
│         │ IP 헤더                 │                       │
│         ├─────────────────────────┤                       │
│         │ TCP 세그먼트            │                       │
│         │  ┌──────────────────┐  │                       │
│         │  │ TCP 헤더         │  │                       │
│         │  ├──────────────────┤  │                       │
│         │  │ HTTP 메시지      │  │                       │
│         │  └──────────────────┘  │                       │
│         └─────────────────────────┘                       │
│                                                           │
├───────────────────────────────────────────────────────────┤
│            FCS (4바이트)                                   │
│            Frame Check Sequence (CRC-32)                  │
│            예: 0x12345678                                 │
└───────────────────────────────────────────────────────────┘

이 전체를 이더넷 프레임 (Ethernet Frame) 이라고 부릅니다.
```

**이더넷 헤더 주요 필드:**

```
목적지 MAC 주소 (Destination MAC Address):
├─ 다음 홉(hop)의 MAC 주소
├─ 같은 네트워크: 목적지 컴퓨터의 MAC
├─ 다른 네트워크: 게이트웨이(라우터)의 MAC
├─ 브로드캐스트: FF:FF:FF:FF:FF:FF
└─ 예: 00:1A:2B:3C:4D:5E

출발지 MAC 주소 (Source MAC Address):
├─ 송신자의 MAC 주소
├─ 랜카드에 고유하게 할당됨
├─ 제조사 코드(OUI) + 시리얼 번호
└─ 예: AA:BB:CC:DD:EE:FF

이더넷 타입 (EtherType):
├─ 상위 계층 프로토콜 식별
├─ 0x0800: IPv4
├─ 0x0806: ARP
├─ 0x86DD: IPv6
└─ 0x8100: VLAN 태그

FCS (Frame Check Sequence):
├─ 프레임 오류 검출
├─ CRC-32 체크섬
├─ 전송 중 데이터 손상 감지
└─ 오류 발견 시 프레임 폐기
```

**MAC 주소 결정 (ARP):**

IP 주소를 알고 있지만 MAC 주소를 모를 때 ARP(Address Resolution Protocol)를 사용합니다:

```
1. 같은 네트워크에 있는 경우:
   내 PC (192.168.0.10)  → 웹 서버 (192.168.0.20)
   ARP 요청: "192.168.0.20의 MAC 주소가 뭐야?" (브로드캐스트)
   ARP 응답: "내 MAC 주소는 00:1A:2B:3C:4D:5E야!" (유니캐스트)

2. 다른 네트워크에 있는 경우:
   내 PC (192.168.0.10)  → 웹 서버 (93.184.216.34)
   목적지 MAC: 게이트웨이(라우터)의 MAC 주소 사용
   라우터가 다음 홉으로 전달
```

#### 5단계: 물리 계층 (Physical Layer) - 전기 신호 변환

물리 계층에서 이더넷 프레임이 전기 신호로 변환되어 네트워크로 전송됩니다. 이 변환을 수행하는 장비가 **랜카드(Network Interface Card, NIC)**입니다.

```
┌───────────────────────────────────────────────────────────┐
│                     랜카드 (NIC)                          │
├───────────────────────────────────────────────────────────┤
│                                                           │
│  이더넷 프레임 (디지털 데이터)                             │
│  ┌──────────────────────────────────────────┐            │
│  │ 01010101... (프리앰블)                    │            │
│  │ 00:1A:2B:3C:4D:5E (목적지 MAC)           │            │
│  │ AA:BB:CC:DD:EE:FF (출발지 MAC)           │            │
│  │ 0x0800 (IPv4)                            │            │
│  │ [IP 헤더 + TCP 헤더 + HTTP 데이터]       │            │
│  │ 0x12345678 (FCS)                         │            │
│  └──────────────────────────────────────────┘            │
│                     ↓                                     │
│              디지털-아날로그 변환                          │
│                     ↓                                     │
│  전기 신호 (전압 변화)                                     │
│  ━━━━┓    ┏━━━━┓    ┏━━━━┓    ┏━━━━                      │
│      ┗━━━━┛    ┗━━━━┛    ┗━━━━┛                          │
│   (1)  (0)  (1)  (0)  (1)  (0) ...                       │
│                     ↓                                     │
│              네트워크 케이블로 전송                         │
│                                                           │
└───────────────────────────────────────────────────────────┘

전기 신호 방식:
┌─────────────────────────────────────────┐
│ 맨체스터 인코딩 (10BASE-T)               │
│  1 비트: ━┓  (고전압에서 저전압)        │
│           ┗━                            │
│  0 비트: ┏━  (저전압에서 고전압)        │
│          ┗━                             │
└─────────────────────────────────────────┘

또는

┌─────────────────────────────────────────┐
│ 4B/5B + MLT-3 인코딩 (100BASE-TX)       │
│ 더 복잡한 인코딩으로 높은 속도 달성      │
└─────────────────────────────────────────┘
```

**랜카드의 역할:**

```
송신 시:
1. 상위 계층에서 이더넷 프레임 수신
2. 프리앰블 추가 (동기화용)
3. 디지털 데이터를 전기 신호로 변환
4. 매체 접근 제어 (CSMA/CD)
5. 케이블로 전기 신호 전송

수신 시:
1. 케이블에서 전기 신호 수신
2. 전기 신호를 디지털 데이터로 변환
3. 프리앰블 제거
4. FCS 검사 (오류 확인)
5. 목적지 MAC 주소 확인
6. 상위 계층으로 전달
```

---

## 32-3. 전체 캡슐화 과정 시각화

### 계층별 PDU (Protocol Data Unit)

각 계층에서 데이터의 이름이 달라집니다:

```
┌──────────────┬────────────────────────┬──────────────────┐
│ 계층          │ PDU 이름               │ 추가되는 정보     │
├──────────────┼────────────────────────┼──────────────────┤
│ 응용 계층     │ 데이터 (Data)          │ HTTP 메시지      │
├──────────────┼────────────────────────┼──────────────────┤
│ 전송 계층     │ 세그먼트 (Segment)     │ TCP/UDP 헤더     │
├──────────────┼────────────────────────┼──────────────────┤
│ 네트워크 계층 │ 패킷 (Packet)          │ IP 헤더          │
├──────────────┼────────────────────────┼──────────────────┤
│ 데이터링크 계층│ 프레임 (Frame)         │ 이더넷 헤더+FCS  │
├──────────────┼────────────────────────┼──────────────────┤
│ 물리 계층     │ 비트 (Bit)             │ 전기 신호        │
└──────────────┴────────────────────────┴──────────────────┘
```

### 캡슐화 상세 과정

```
[응용 계층]
┌─────────────────────────────────────────┐
│ GET /index.html HTTP/1.1                │
│ Host: www.example.com                   │
│ ...                                     │
└─────────────────────────────────────────┘
                   ↓
[전송 계층] TCP 헤더 추가
┌───────────┬─────────────────────────────┐
│ TCP 헤더  │ HTTP 메시지                 │
│ 20바이트  │                             │
└───────────┴─────────────────────────────┘
      ↑
      세그먼트 (Segment)
                   ↓
[네트워크 계층] IP 헤더 추가
┌───────────┬───────────┬─────────────────┐
│ IP 헤더   │ TCP 헤더  │ HTTP 메시지     │
│ 20바이트  │ 20바이트  │                 │
└───────────┴───────────┴─────────────────┘
      ↑
      패킷 (Packet)
                   ↓
[데이터링크 계층] 이더넷 헤더+FCS 추가
┌──────────┬──────┬──────┬──────┬──────┐
│이더넷헤더│IP헤더│TCP헤더│HTTP │ FCS  │
│ 14바이트 │20바이트│20바이트│데이터│4바이트│
└──────────┴──────┴──────┴──────┴──────┘
      ↑
      프레임 (Frame)
                   ↓
[물리 계층] 전기 신호 변환
━━━━┓    ┏━━━━┓    ┏━━━━┓    ┏━━━━
    ┗━━━━┛    ┗━━━━┛    ┗━━━━┛
(전기 신호로 네트워크에 전송)
```

### 헤더 크기 계산

```
최소 헤더 크기:
┌──────────────────────────────────────┐
│ 이더넷 헤더: 14바이트                 │
│ + IP 헤더:   20바이트                 │
│ + TCP 헤더:  20바이트                 │
│ ────────────────────                 │
│ = 총 오버헤드: 54바이트               │
└──────────────────────────────────────┘

실제 HTTP 요청 예시:
┌──────────────────────────────────────┐
│ HTTP 메시지: 200바이트                │
│ + TCP 헤더:   20바이트                │
│ + IP 헤더:    20바이트                │
│ + 이더넷 헤더: 14바이트               │
│ + FCS:         4바이트                │
│ ────────────────────                 │
│ = 전체 프레임: 258바이트              │
└──────────────────────────────────────┘

오버헤드 비율: 58바이트 / 258바이트 = 22.5%
```

---

## 32-4. 역캡슐화 (Decapsulation) 과정

웹 서버에서 데이터를 수신할 때는 반대로 역캡슐화가 이루어집니다:

```
[물리 계층]
전기 신호 수신
━━━━┓    ┏━━━━┓    ┏━━━━┓    ┏━━━━
    ┗━━━━┛    ┗━━━━┛    ┗━━━━┛
                   ↓
디지털 데이터로 변환
                   ↓
[데이터링크 계층]
┌──────────┬──────┬──────┬──────┬──────┐
│이더넷헤더│IP헤더│TCP헤더│HTTP │ FCS  │
└──────────┴──────┴──────┴──────┴──────┘
1. FCS 체크 (오류 확인)
2. 목적지 MAC 주소 확인 (내 것인가?)
3. 이더넷 헤더와 FCS 제거
                   ↓
[네트워크 계층]
┌───────────┬───────────┬─────────────────┐
│ IP 헤더   │ TCP 헤더  │ HTTP 메시지     │
└───────────┴───────────┴─────────────────┘
1. 목적지 IP 주소 확인 (내 것인가?)
2. TTL 확인
3. 체크섬 검증
4. IP 헤더 제거
                   ↓
[전송 계층]
┌───────────┬─────────────────────────────┐
│ TCP 헤더  │ HTTP 메시지                 │
└───────────┴─────────────────────────────┘
1. 목적지 포트 번호 확인 (80번?)
2. 체크섬 검증
3. 시퀀스 번호 확인
4. ACK 전송
5. TCP 헤더 제거
                   ↓
[응용 계층]
┌─────────────────────────────────────────┐
│ GET /index.html HTTP/1.1                │
│ Host: www.example.com                   │
│ ...                                     │
└─────────────────────────────────────────┘
웹 서버 프로그램이 HTTP 요청 처리
```

---

## 32-5. 실제 패킷 캡처 예제

### Wireshark로 패킷 분석

Wireshark를 사용하면 실제 패킷의 각 계층을 볼 수 있습니다:

```
# Wireshark 필터 예제
http                     # HTTP 패킷만 표시
tcp.port == 80           # 80번 포트 사용하는 패킷
ip.addr == 93.184.216.34 # 특정 IP 주소
eth.addr == AA:BB:CC:DD:EE:FF  # 특정 MAC 주소
```

**Wireshark 화면 구조:**

```
┌──────────────────────────────────────────────────────┐
│           패킷 목록 (Packet List)                     │
├──────────────────────────────────────────────────────┤
│ No. Time    Source          Destination   Protocol   │
│ 1   0.000   192.168.0.10    93.184.216.34 HTTP       │
│ 2   0.050   93.184.216.34   192.168.0.10  HTTP       │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│           패킷 상세 (Packet Details)                  │
├──────────────────────────────────────────────────────┤
│ ▶ Frame 1: 258 bytes on wire                         │
│ ▼ Ethernet II                                        │
│     Destination: 00:1a:2b:3c:4d:5e                   │
│     Source: aa:bb:cc:dd:ee:ff                        │
│     Type: IPv4 (0x0800)                              │
│ ▼ Internet Protocol Version 4                       │
│     Version: 4                                       │
│     Header Length: 20 bytes                          │
│     Total Length: 244                                │
│     Protocol: TCP (6)                                │
│     Source: 192.168.0.10                             │
│     Destination: 93.184.216.34                       │
│ ▼ Transmission Control Protocol                     │
│     Source Port: 54321                               │
│     Destination Port: 80                             │
│     Sequence number: 1                               │
│     Acknowledgment number: 1                         │
│     Flags: 0x018 (PSH, ACK)                          │
│ ▼ Hypertext Transfer Protocol                       │
│     GET /index.html HTTP/1.1\r\n                     │
│     Host: www.example.com\r\n                        │
│     User-Agent: Mozilla/5.0\r\n                      │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│           패킷 바이트 (Packet Bytes)                  │
├──────────────────────────────────────────────────────┤
│ 0000  00 1a 2b 3c 4d 5e aa bb cc dd ee ff 08 00 45 00│
│ 0010  00 f4 30 39 40 00 40 06 2c 65 c0 a8 00 0a 5d b8│
│ 0020  d8 22 d4 51 00 50 00 00 00 01 00 00 00 01 50 18│
│ ...                                                  │
└──────────────────────────────────────────────────────┘
```

### tcpdump로 패킷 캡처

```bash
# 80번 포트 패킷 캡처 (HTTP)
sudo tcpdump -i eth0 port 80 -vv

# 특정 IP 주소와의 통신 캡처
sudo tcpdump -i eth0 host 93.184.216.34

# 패킷을 파일로 저장
sudo tcpdump -i eth0 port 80 -w capture.pcap

# 저장된 파일 읽기
tcpdump -r capture.pcap

# ASCII로 패킷 내용 출력
sudo tcpdump -i eth0 port 80 -A

# 예시 출력
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
10:30:45.123456 IP 192.168.0.10.54321 > 93.184.216.34.80: Flags [P.], seq 1:201, ack 1, win 65535, length 200
    0x0000:  001a 2b3c 4d5e aabb ccdd eeff 0800 4500
    0x0010:  00f4 3039 4000 4006 2c65 c0a8 000a 5db8
    0x0020:  d822 d451 0050 0000 0001 0000 0001 5018
    ...
```

---

## 32-6. MTU와 단편화

### MTU (Maximum Transmission Unit)

네트워크에서 전송할 수 있는 최대 패킷 크기를 MTU라고 합니다:

```
┌────────────────────────────────────────────────────┐
│              이더넷 MTU: 1500바이트                 │
├────────────────────────────────────────────────────┤
│                                                    │
│ ┌────────────┬──────────────────────────────────┐ │
│ │ IP 헤더    │ 데이터 (TCP 세그먼트)             │ │
│ │ 20바이트   │ 최대 1480바이트                   │ │
│ └────────────┴──────────────────────────────────┘ │
│                                                    │
└────────────────────────────────────────────────────┘

실제 이더넷 프레임:
┌──────────┬────────┬──────┐
│이더넷헤더│ 1500   │ FCS  │
│ 14바이트 │바이트  │4바이트│
└──────────┴────────┴──────┘
총: 1518바이트
```

**MTU 확인:**

```bash
# Linux
ip link show
ifconfig

# 출력 예시
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
      ↑ MTU 값

# Windows
netsh interface ipv4 show interfaces

# 출력 예시
Idx  Met  MTU         State        Name
---  ---  -----       -----------  -------------------
  1   75  4294967295  connected    Loopback Pseudo-Interface 1
  2   25  1500        connected    Local Area Connection
              ↑ MTU 값
```

### IP 단편화 (IP Fragmentation)

데이터가 MTU보다 크면 IP 계층에서 단편화가 발생합니다:

```
원본 패킷 (2000바이트 데이터):
┌──────┬──────────────────────────────────┐
│IP헤더│        데이터 (2000바이트)        │
│20바이트│                                   │
└──────┴──────────────────────────────────┘

단편화 후 (MTU 1500):
┌──────┬─────────────────────────┐
│IP헤더│  데이터 (1480바이트)    │ ← 조각 1
│20바이트│ Fragment Offset: 0     │
└──────┴─────────────────────────┘

┌──────┬─────────────────────────┐
│IP헤더│  데이터 (520바이트)     │ ← 조각 2
│20바이트│ Fragment Offset: 1480  │
└──────┴─────────────────────────┘

수신 측에서 재조립
```

**단편화 관련 IP 헤더 필드:**

```
식별자 (Identification):
├─ 같은 원본 패킷의 조각들은 같은 식별자
└─ 예: 12345

플래그 (Flags):
├─ DF (Don't Fragment): 단편화 금지
├─ MF (More Fragments): 뒤에 조각이 더 있음
└─ 마지막 조각은 MF=0

단편화 오프셋 (Fragment Offset):
├─ 원본 데이터에서의 위치
├─ 단위: 8바이트
└─ 예: 0, 185 (1480/8), 250 (2000/8)
```

**Path MTU Discovery:**

단편화를 피하기 위해 경로상의 최소 MTU를 찾습니다:

```bash
# Linux에서 PMTU 확인
ip route get 93.184.216.34

# 출력 예시
93.184.216.34 via 192.168.0.1 dev eth0 src 192.168.0.10
    cache expires 592sec mtu 1500

# DF 플래그 설정하여 ping
ping -M do -s 1472 93.184.216.34
# 1472 = 1500 (MTU) - 20 (IP 헤더) - 8 (ICMP 헤더)
```

---

## 32-7. 네트워크 장비에서의 처리

### 허브 (Hub) - 물리 계층 장비

허브는 물리 계층에서 동작하며, 받은 전기 신호를 모든 포트로 전달합니다:

```
        허브 (Hub)
        ┌─────┐
    ┌───┤  1  ├───┐
    │   ├─────┤   │
포트2│   │  2  │   │포트1
────┴───┤  3  ├───┴────
        │  4  │
        └──┬──┘
           │포트3
           │

특징:
- 모든 포트로 브로드캐스트
- 충돌 도메인 공유
- 반이중 통신
- 성능 저하 (충돌 많음)
```

### 스위치 (Switch) - 데이터링크 계층 장비

스위치는 데이터링크 계층에서 동작하며, MAC 주소 테이블을 이용해 지능적으로 전달합니다:

```
        스위치 (Switch)
        ┌─────────────┐
    ┌───┤   1         │
    │   ├─────────────┤
포트2│   │   2         │   포트1
────┴───┤   3         ├───┴────
        │   4         │
        └──┬──────────┘
           │포트3
           │

MAC 주소 테이블:
┌──────┬─────────────────┐
│ 포트 │ MAC 주소         │
├──────┼─────────────────┤
│  1   │ AA:BB:CC:DD:EE:FF│
│  2   │ 11:22:33:44:55:66│
│  3   │ 77:88:99:AA:BB:CC│
└──────┴─────────────────┘

특징:
- 목적지 MAC 주소로 선택적 전달
- 충돌 도메인 분리
- 전이중 통신
- 높은 성능
```

**스위치 동작 과정:**

```
1. 프레임 수신
   ┌──────────┬──────┬──────┬──────┬──────┐
   │이더넷헤더│IP헤더│TCP헤더│데이터│ FCS  │
   │목적:     │      │      │      │      │
   │11:22:... │      │      │      │      │
   └──────────┴──────┴──────┴──────┴──────┘

2. 목적지 MAC 주소 확인
   목적지: 11:22:33:44:55:66

3. MAC 주소 테이블 조회
   11:22:33:44:55:66 → 포트 2

4. 포트 2로만 전달
   (다른 포트로는 전달하지 않음)

5. 출발지 MAC 주소 학습
   출발지: AA:BB:CC:DD:EE:FF → 포트 1에 연결됨
   (테이블에 없으면 추가)
```

### 라우터 (Router) - 네트워크 계층 장비

라우터는 네트워크 계층에서 동작하며, IP 주소를 이용해 패킷을 다른 네트워크로 전달합니다:

```
      라우터 (Router)
      ┌─────────────┐
LAN 1 │   eth0      │ WAN
192.  ├─────────────┤ 인터넷
168.  │   eth1      │
0.0/24│   eth2      │
      └─────────────┘
         │
      LAN 2
      10.0.0.0/24

특징:
- IP 주소 기반 라우팅
- 브로드캐스트 도메인 분리
- NAT, 방화벽 기능
- 다른 네트워크 간 연결
```

**라우터 동작 과정:**

```
1. 프레임 수신 (데이터링크 계층)
   이더넷 헤더 확인 → 제거

2. 패킷 확인 (네트워크 계층)
   목적지 IP: 93.184.216.34

3. 라우팅 테이블 조회
   ┌──────────────┬─────────┬────────────┐
   │ 목적지       │ 게이트웨이│ 인터페이스 │
   ├──────────────┼─────────┼────────────┤
   │ 192.168.0.0/24│ *       │ eth0       │
   │ 10.0.0.0/24  │ *       │ eth1       │
   │ 0.0.0.0/0    │ ISP라우터│ eth2       │ ← 기본 경로
   └──────────────┴─────────┴────────────┘

4. TTL 감소
   TTL: 64 → 63

5. 새로운 이더넷 헤더 생성
   출발지 MAC: 라우터의 eth2 MAC
   목적지 MAC: 다음 홉(ISP 라우터)의 MAC

6. 전달
   eth2 인터페이스로 전송
```

---

## 32-8. 실습: 패킷 경로 추적

### 1. 로컬 네트워크 정보 확인

```bash
# IP 주소 확인 (Linux)
ip addr show
# 또는
ifconfig

# IP 주소 확인 (Windows)
ipconfig

# 출력 예시
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
    inet 192.168.0.10/24 brd 192.168.0.255 scope global eth0
    ether aa:bb:cc:dd:ee:ff (MAC 주소)
```

### 2. 게이트웨이 확인

```bash
# 기본 게이트웨이 확인 (Linux)
ip route show
# 또는
route -n

# 출력 예시
default via 192.168.0.1 dev eth0
        ↑ 게이트웨이

# Windows
ipconfig | findstr "Default Gateway"
route print
```

### 3. ARP 테이블 확인

```bash
# ARP 테이블 조회
arp -a

# 출력 예시
? (192.168.0.1) at 00:11:22:33:44:55 [ether] on eth0
  ↑ IP 주소        ↑ MAC 주소

# 특정 IP의 MAC 주소 확인
arp -a 192.168.0.1

# ARP 캐시 삭제 (관리자 권한 필요)
sudo arp -d 192.168.0.1  # Linux
arp -d 192.168.0.1       # Windows
```

### 4. 경로 추적

```bash
# traceroute (Linux)
traceroute www.example.com

# tracert (Windows)
tracert www.example.com

# 예시 출력
traceroute to www.example.com (93.184.216.34), 30 hops max
 1  gateway (192.168.0.1)  1.234 ms  # 내 게이트웨이
 2  10.0.0.1 (10.0.0.1)  5.432 ms   # ISP 라우터
 3  203.0.113.1 (203.0.113.1)  10.123 ms
 4  198.51.100.1 (198.51.100.1)  15.234 ms
 5  93.184.216.34 (93.184.216.34)  20.456 ms  # 목적지
```

### 5. 네트워크 인터페이스 통계

```bash
# 인터페이스 통계 (Linux)
ip -s link show eth0

# 출력 예시
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
    RX: bytes  packets  errors  dropped overrun mcast
    1234567    5678     0       0       0       123
    TX: bytes  packets  errors  dropped carrier collsns
    2345678    6789     0       0       0       0

# netstat으로 통계 (Linux/Windows)
netstat -i  # Linux
netstat -e  # Windows
```

### 6. 실시간 패킷 모니터링

```bash
# iftop으로 실시간 대역폭 모니터링 (Linux)
sudo iftop -i eth0

# nethogs로 프로세스별 네트워크 사용량 (Linux)
sudo nethogs eth0

# nload로 실시간 트래픽 그래프 (Linux)
nload eth0

# Windows Resource Monitor
resmon.exe
(네트워크 탭에서 확인)
```

---

## 32-9. 성능 최적화

### TCP Window Scaling

윈도우 크기를 확장하여 고속 네트워크에서 성능 향상:

```
기본 윈도우 크기:
- TCP 헤더의 윈도우 크기 필드: 16비트
- 최대값: 65535 바이트 (64KB)
- 고속 네트워크에서는 부족

Window Scaling (RFC 1323):
- TCP 옵션으로 스케일 팩터 협상
- 실제 윈도우 크기 = 윈도우 필드 × 2^(스케일팩터)
- 최대값: 65535 × 2^14 = 1GB

예시:
┌─────────────────────────────────────┐
│ TCP 옵션:                           │
│ - MSS: 1460                         │
│ - Window Scale: 7                   │
│                                     │
│ 윈도우 크기: 65535 (헤더 값)         │
│ 실제 윈도우: 65535 × 2^7 = 8,388,480│
│            (약 8MB)                 │
└─────────────────────────────────────┘
```

**설정 확인 및 조정 (Linux):**

```bash
# 현재 설정 확인
sysctl net.ipv4.tcp_window_scaling

# 윈도우 스케일링 활성화
sudo sysctl -w net.ipv4.tcp_window_scaling=1

# 수신 버퍼 크기 조정
sudo sysctl -w net.ipv4.tcp_rmem="4096 87380 6291456"
sudo sysctl -w net.ipv4.tcp_wmem="4096 16384 4194304"
```

### TCP Offloading

랜카드에서 TCP 처리를 하드웨어로 수행하여 CPU 부하 감소:

```
TSO (TCP Segmentation Offload):
- 큰 데이터를 랜카드가 세그먼트로 분할
- CPU 부하 감소

LRO (Large Receive Offload):
- 여러 세그먼트를 랜카드가 하나로 합침
- 인터럽트 횟수 감소

Checksum Offload:
- TCP/IP 체크섬 계산을 랜카드가 수행
- CPU 부하 감소
```

**설정 확인 및 조정 (Linux):**

```bash
# 오프로드 설정 확인
ethtool -k eth0

# 출력 예시
tcp-segmentation-offload: on
generic-segmentation-offload: on
generic-receive-offload: on
rx-checksumming: on
tx-checksumming: on

# TSO 활성화
sudo ethtool -K eth0 tso on

# Checksum offload 활성화
sudo ethtool -K eth0 rx on tx on
```

---

## 정리

### OSI 7계층과 캡슐화

```yaml
응용 계층 (Layer 7):
  - HTTP, FTP, SMTP, DNS 등 프로토콜
  - 애플리케이션이 사용하는 데이터
  - PDU: 데이터 (Data)

전송 계층 (Layer 4):
  - TCP, UDP 프로토콜
  - 포트 번호로 애플리케이션 식별
  - 신뢰성 있는 데이터 전송
  - TCP 헤더 추가
  - PDU: 세그먼트 (Segment)

네트워크 계층 (Layer 3):
  - IP 프로토콜
  - IP 주소로 목적지 지정
  - 라우팅으로 경로 결정
  - IP 헤더 추가
  - PDU: 패킷 (Packet)

데이터링크 계층 (Layer 2):
  - 이더넷 프로토콜
  - MAC 주소로 물리적 주소 지정
  - 같은 네트워크 내 전송
  - 이더넷 헤더와 FCS 추가
  - PDU: 프레임 (Frame)

물리 계층 (Layer 1):
  - 랜카드, 케이블, 허브
  - 디지털 데이터를 전기 신호로 변환
  - 네트워크 매체를 통해 전송
  - PDU: 비트 (Bit)
```

### 웹 접속 시 전체 흐름

```
1. 응용 계층:
   - 웹 브라우저가 HTTP 요청 생성
   - GET /index.html HTTP/1.1

2. 전송 계층:
   - TCP 헤더 추가 (출발지 포트: 54321, 목적지 포트: 80)
   - 세그먼트 생성

3. 네트워크 계층:
   - IP 헤더 추가 (출발지 IP, 목적지 IP)
   - IP 패킷 생성

4. 데이터링크 계층:
   - ARP로 목적지 MAC 주소 확인
   - 이더넷 헤더와 FCS 추가
   - 이더넷 프레임 생성

5. 물리 계층:
   - 랜카드가 전기 신호로 변환
   - 네트워크 케이블로 전송

6. 네트워크 전송:
   - 스위치: MAC 주소로 전달
   - 라우터: IP 주소로 라우팅
   - 목적지까지 홉(hop) 전달

7. 수신 측 역캡슐화:
   - 물리 계층: 전기 신호 → 디지털 데이터
   - 데이터링크: 이더넷 헤더 제거, FCS 확인
   - 네트워크: IP 헤더 제거, 라우팅 확인
   - 전송: TCP 헤더 제거, 포트 확인
   - 응용: HTTP 요청 처리
```

### 핵심 개념

```
캡슐화 (Encapsulation):
- 각 계층에서 헤더(또는 트레일러) 추가
- 상위 계층 데이터를 하위 계층이 캡슐화
- 송신 측에서 수행

역캡슐화 (Decapsulation):
- 각 계층에서 헤더(또는 트레일러) 제거
- 하위 계층 데이터를 상위 계층으로 전달
- 수신 측에서 수행

랜카드 (NIC):
- Network Interface Card
- 디지털 데이터를 전기 신호로 변환
- MAC 주소 보유
- 물리 계층 장비

MTU (Maximum Transmission Unit):
- 네트워크에서 전송 가능한 최대 패킷 크기
- 이더넷: 1500 바이트
- MTU 초과 시 IP 단편화 발생
```

---

**관련 문서:**
- [24. TCP의 구조](../24-tcp-structure) - TCP 세그먼트 구조
- [26. 포트 번호의 구조](../26-port-number-structure) - TCP/UDP 포트
- [23. 전송 계층의 역할](../23-transport-layer-role) - 전송 계층 개념
